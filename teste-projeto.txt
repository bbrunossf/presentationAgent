Token Usage:
GitHub Tokens: 36320
LLM Input Tokens: 0
LLM Output Tokens: 0
Total Tokens: 36320

FileTree:
.gitignore
README.md
app/backend/agent/agent.py
app/backend/agent/main.py
app/backend/agent/outputs/agent-response.json
app/backend/agent/requirements.txt
app/backend/agent/tools.py
app/backend/agent/whisper_handler.py
app/backend/docker-compose.yml
app/components/Canvas.tsx
app/components/CommandInput.tsx
app/components/Header.tsx
app/components/Layout.tsx
app/components/OutputDisplay.tsx
app/components/Sidebar.tsx
app/components/VoiceInput.tsx
app/components/WorkloadChart.tsx
app/data/routes.json
app/entry.client.tsx
app/entry.server.tsx
app/root.tsx
app/routes/_index.tsx
app/routes/api.run-agent.ts
app/routes/api.transcribe.ts
app/services/remoteAgent.ts
app/store/useCommandStore.ts
app/tailwind.css
app/types/AgentResponse.ts
app/utils/generateRoute.ts
app/utils/writeRouteToFile.ts
package.json
postcss.config.js
remix.config.js
remix.env.d.ts
tailwind.config.ts
teste-projeto.txt
tsconfig.json
vite.config.ts

Analysis:
.gitignore

node_modules

/.cache
/build
.env
README.md

Projeto Agente PPT
Objetivo
O objetivo desse projeto é criar uma interface onde seja possível passar informações para um agente de IA, e exibir os resultados na mesma página, em uma seção exclusiva.
O projeto vai utilizar o framework Remix, e todas as bibliotecas usadas serão registradas nesse arquivo.

Declaração de Escopo do Projeto
Interface Intuitiva: Crie uma página com uma interface amigável onde você possa interagir com o agente. Inclua um campo de entrada para comandos ou perguntas.

Canvas ou Painel de Resultados: Dedique uma seção da página para exibir os resultados das tarefas executadas. Pode ser um canvas para visualizações gráficas ou um painel para texto e gráficos.

Comunicação com a API: Configure a comunicação entre sua aplicação e a API do agente de IA para enviar comandos e receber resultados.

Demonstração ao Vivo: Durante a palestra, execute comandos ao vivo e mostre como o agente processa as tarefas, exibindo os resultados no painel em tempo real.

Etapas de desenvolvimento
API para Modificação de Rotas: Crie uma API no Remix que permita modificar ou salvar informações relacionadas às rotas. Por exemplo, um endpoint POST que recebe dados para atualizar uma rota específica.

Detecção de Mudança: Implemente um sistema de detecção de mudanças no lado do servidor, que atualize a interface do usuário quando uma rota for modificada.

Re-renderização Automática: Utilize a funcionalidade de revalidação ou re-renderização automática do Remix para refletir as mudanças na interface do usuário assim que a rota for atualizada.

Feedback Visual: Garanta que o painel ou canvas na página mostre claramente as mudanças em tempo real, proporcionando um feedback visual instantâneo.

Estrutura inicial do Projeto
Relação de pastas e arquivos necessários
/app
├── /routes
│ ├── index.tsx # Rota principal que renderiza a interface geral
│ ├── /generated # Pasta para armazenar as rotas geradas dinamicamente
│ │ └── newRoute.tsx # Exemplo de uma rota gerada dinamicamente
├── /components
│ ├── Layout.tsx # Layout principal da aplicação
│ ├── Sidebar.tsx # Componente para a navegação lateral
│ ├── WorkloadChart.tsx # Componente para renderizar o gráfico de carga de trabalho
├── /utils
│ ├── generateRoute.ts # Função para gerar código de novas rotas
│ └── writeRouteToFile.ts # Função para escrever o código gerado no arquivo da rota
├── /services
│ └── agent.ts # Agente de IA que gera o código das rotas
├── /styles
│ └── global.css # Estilos globais
├── /data
│ └── routes.json # Arquivo JSON que mantém o histórico das rotas geradas
└── /config
└── remix.config.js # Arquivo de configuração do Remix

app/backend/agent/agent.py

# agent.py
from tools import AgentTools
from openai import OpenAI
import os
import json

class AIAgent:
    def __init__(self):
        self.tools = AgentTools()
        self.client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])
        
    def process_request(self, request):
        """Processa uma solicitação e determina a resposta apropriada"""
        #print (request)
        print (request)
        
        # Primeiro, verifica se o agente pode lidar com o comando diretamente
        direct_commands = {
            "listar projetos": self.handle_project_listing,
            "gráfico de vendas": self.tools.generate_sales_chart,
            "gerar gráfico": self.tools.generate_sales_chart,
            "vendas": self.tools.generate_sales_chart
        }
        
        # Verificar se algum dos comandos diretos está na solicitação
        for cmd, handler in direct_commands.items():
            if cmd.lower() in request.lower():
                return handler()
        
        # Se não for um comando direto, use a API OpenAI para interpretar a solicitação
        return self.interpret_with_openai(request)

    def handle_project_listing(self):
        """Lista todos os projetos do banco de dados"""
        # Consulta ao banco de dados para listar projetos
        projects = self.tools.query_sqlite("SELECT * FROM projects")
        response = {
            "type": "database",
            "content": projects,
            "metadata": {"query": "Listar todos os projetos"}
        }
        # Salva a resposta em JSON
        self.tools.save_agent_response(response)
        return response
        
    def interpret_with_openai(self, user_input):
        """Usa a API OpenAI para interpretar e responder à solicitação"""
        # Definir as ferramentas disponíveis para a API
        tools = [
            {
                "type": "function",
                "function": {
                    "name": "query_database",
                    "description": "Consulta o banco de dados para obter informações",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "sql_query": {
                                "type": "string",
                                "description": "Consulta SQL a ser executada"
                            }
                        },
                        "required": ["sql_query"]
                    }
                }
            },
            {
                "type": "function",
                "function": {
                    "name": "generate_sales_chart",
                    "description": "Gera um gráfico de vendas mensais",
                    "parameters": {
                        "type": "object",
                        "properties": {}
                    }
                }
            }
        ]
        
        # Primeira chamada para determinar se precisamos de uma ferramenta
        messages = [{"role": "user", "content": user_input}]
        response = self.client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            tools=tools,
            tool_choice="auto"
        )
        
        message = response.choices[0].message
        print(message)
        #ChatCompletionMessage(content='Olá! Como posso ajudar você hoje?', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None)
        
        # Verificar se o modelo quer usar uma ferramenta
        if message.tool_calls:
            # Executar a ferramenta solicitada
            tool_call = message.tool_calls[0]
            function_name = tool_call.function.name
            function_args = json.loads(tool_call.function.arguments)
            
            tool_result = None
            if function_name == "query_database":
                tool_result = self.tools.query_sqlite(function_args["sql_query"])
            elif function_name == "generate_sales_chart":
                return self.tools.generate_sales_chart()
            
            # Adicionar o resultado da ferramenta à conversa
            messages.append(message)
            messages.append({
                "tool_call_id": tool_call.id,
                "role": "tool",
                "name": function_name,
                "content": json.dumps(tool_result)
            })
            
            # Obter resposta final com o resultado da ferramenta
            final_response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=messages
            )
            
            result = {
                "type": "tool_assisted",
                "tool": function_name,
                "content": final_response.choices[0].message.content,
                "raw_data": tool_result
            }
            
            # Salvar em JSON se estiver usando ferramentas
            self.tools.save_agent_response(result)
            
            return result
        else:
            # Se não precisar de ferramenta, retornar resposta direta
            print(f"a resposta não formatada foi {message.content}")
            return {
                "type": "text",
                "content": message.content
            }
app/backend/agent/main.py

from fastapi import FastAPI, UploadFile, File, Request, HTTPException
from whisper_handler import transcribe_audio
from openai import OpenAI
import os
from pydantic import BaseModel  # only used by OpenAIPrompt
from agent import AIAgent

app = FastAPI()
client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])
agent = AIAgent()


class OpenAIPrompt(BaseModel):
    prompt: str
    
# @app.post("/agent/process")
# async def get_agent_response(request: AgentRequest):
##async def get_agent_response(request):
    # """Endpoint para processar comandos diretos usando o agente"""
    # response = agent.process_request(request.command)
    ##response = agent.process_request(request)
    # print(response)
    # return response
    
@app.post("/agent/process")
async def process_command(request: Request):
    # Simplified: parse JSON body manually, no Pydantic
    data = await request.json()
    command = data.get("command")
    if not isinstance(command, str):
        raise HTTPException(status_code=400, detail="Missing or invalid 'command' field")
    # Delegate to agent with the raw command string
    result = agent.process_request(command)
    return result

@app.post("/agent/openai")
async def process_openai(input: OpenAIPrompt):
    """Endpoint para processar prompts diretos via OpenAI"""
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[{"role": "user", "content": input.prompt}]
    )
    return {
        "type": "text",
        "prompt": input.prompt,
        "response": response.choices[0].message.content
    }
    

@app.post("/transcribe")
async def transcribe(file: UploadFile = File(...)):
    transcript = await transcribe_audio(file)
    #return {"text": transcript}
    print("Transcrição gerada:", transcript)
    return {"text": transcript}
app/backend/agent/outputs/agent-response.json

{
  "type": "chart",
  "content": "iVBORw0KGgoAAAANSUhEUgAAA+gAAAJYCAYAAADxHswlAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAAWERJREFUeJzt3XlcVfW+//H32hsZRIFEBA1U0kzQnHAIrcwc0CgbrNSslLSupvZTK4dOaXY8OXUb1azTTTqd7Jidm5ZjHk2tI2Uq5pRDiZmHQBwABQVhr98fXpZugUSz9trwej4ePh7xWd+99uezXbt6s9Ze2zBN0xQAAAAAAPAoh6cbAAAAAAAABHQAAAAAAGyBgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAACvZpqmZs6cqaVLl3q6FQAAfhMCOgAANjFo0CA1bNjQ0214nVmzZmnu3Ll68MEHdeDAAU+3AwDAZSOgAwCqnN69e6t69eo6ceJEuWsGDBggX19fHT169A/srOo5cOCADMOQYRiaMmVKmWsGDBggwzBUo0aNUtv279+vKVOmaMmSJRo/frwGDx4s0zR/77YBAPhdENABAFXOgAEDdOrUKX3yySdlbs/Pz9fixYvVs2dPhYaG/sHdVU3+/v768MMPS9Xz8vK0ePFi+fv7l/m477//Xn/7298UExOjsWPHKjExUT///PPv3S4AAL8LAjoAoMrp3bu3atasqfnz55e5ffHixcrLy9OAAQP+4M4qp7y8vIuuue2227Rr1y599913bvXFixersLBQ3bt3L/NxiYmJSkhIkCQZhqExY8aofv36v71pAAA8gIAOAKhyAgICdM8992j16tU6fPhwqe3z589XzZo11bt3b0lSdna2Ro0apaioKPn5+alx48aaPn26XC6X9ZiSS7Vfeuklvf3222rUqJH8/PzUrl07ffvtt6WeY9GiRWrevLn8/f3VvHnzcs/mv/TSS+rYsaNCQ0MVEBCguLg4ffzxx6XWrVq1SjfeeKNCQkJUo0YNXXfddXrmmWcu+loYhqERI0bogw8+0HXXXSd/f3/FxcVp/fr1pdampqaqV69eCgoKUo0aNdS1a1d9/fXXbmuSk5NlGIbWrVunxx9/XHXq1FFkZORF+4iPj1d0dHSpX5p88MEH6tmzp2rVqlXm45YvX66bbrpJgYGBqlmzphITE7Vz5063NRkZGUpKSlJkZKT8/PxUt25d3XnnnXxeHQBgO4bJB7UAAFXQqlWr1KNHD73xxhsaMWKEVT927JgiIiLUv39/vffee8rPz1d8fLz+85//6L/+679Uv359bdiwQe+//76eeOIJvfrqq5LOBvTo6Gi1bt1aJ06c0KOPPirDMDRjxgz5+/tr//79qlatmiTp888/V69evRQbG6tHHnlER48e1axZsxQZGamTJ0+6BceoqCj17t1bsbGxKiws1D/+8Q9t3LhRS5YsUWJioiRp586datOmjVq0aKGHHnpIfn5++uGHH7Rx40atW7fuV18HwzDUvHlzZWRk6IknnpCfn5/mzJmjw4cPa+PGjWrevLn1HB06dFBQUJAef/xxVatWTW+99ZbS09O1bt06dejQQdLZgJ6UlKTY2FiFhYXp3nvvVV5ensaNG1fm85e8bjNnztTx48f197//3fplx5EjR1S3bl29//77WrFihT7++GOdPHnSeuz777+vgQMHKiEhQYmJicrPz9ebb76p7OxspaamWjfc69Spk3bu3KmRI0eqYcOGOnz4sFatWqXnn39eN998c8UPGgAAfm8mAABVUFFRkVm3bl0zPj7erT537lxTkrly5UrTNE3zz3/+sxkYGGju3bvXbd348eNNp9NpHjx40DRN00xLSzMlmaGhoeaxY8esdYsXLzYlmZ999plVa9WqlVm3bl0zOzvbqn3++eemJLNBgwZuz5Ofn+/2c2Fhodm8eXPz1ltvtWqvvPKKKcnMysq65NdBkinJ3LRpk1X76aefTH9/f/Puu++2anfddZfp6+tr/vjjj1YtPT3drFmzpnnzzTdbtXnz5pmSzBtvvNEsKiq66POXvG4zZ840d+zYYUoyv/zyS9M0TXP27NlmjRo1zLy8PHPgwIFmYGCg9bgTJ06YISEh5qOPPuq2v4yMDDM4ONiqHz9+3No/AAB2xyXuAIAqyel0ql+/fkpJSXE7Yz1//nyFh4era9eukqSFCxfqpptu0lVXXaUjR45Yf7p166bi4uJSl4L37dtXV111lfXzTTfdJOns3cYl6ZdfftHWrVs1cOBABQcHW+u6d++u2NjYUn0GBARY/3z8+HHl5OTopptu0pYtW6x6SEiIpLOf1z7/svuKio+PV1xcnPVz/fr1deedd2rlypUqLi5WcXGxPv/8c91111265pprrHV169bVAw88oK+++kq5ublu+3z00UfldDovqY9mzZqpRYsW1s3i5s+frzvvvFPVq1cvtXbVqlXKzs5W//793f5enE6nOnTooC+++ELS2dfP19dXa9eu1fHjxy+pHwAA/mgEdABAlVVyE7iSzz0fOnRIX375pfr162eFy3379mnFihUKCwtz+9OtWzdJKvUZ9gtvUFYS1kvC4U8//SRJuvbaa0v1c91115WqLVmyRDfccIP8/f1Vq1YthYWF6c0331ROTo61pm/fvurUqZOGDBmi8PBw9evXTx999FGFw3pZvTRp0kT5+fnKyspSVlaW8vPzy+wvJiZGLper1J3To6OjK/TcF3rggQe0cOFC/fDDD9qwYYMeeOCBMtft27dPknTrrbeW+rv5/PPPrb8XPz8/TZ8+XcuXL1d4eLhuvvlmzZgxQxkZGZfVHwAAvycfTzcAAICnxMXFqWnTpvrwww/1zDPP6MMPP5Rpmm53b3e5XOrevbvGjh1b5j6aNGni9nN5Z43Ny7jly5dffqnevXvr5ptv1pw5c1S3bl1Vq1ZN8+bNc7uZWkBAgNavX68vvvhCS5cu1YoVK7RgwQLdeuut+vzzzy/5TPaVcP6Z/0vRv39/TZgwQY8++qhCQ0PVo0ePMteV/PLh/fffV0RERKntPj7n/hdn1KhRuuOOO7Ro0SKtXLlSzz33nKZOnao1a9aodevWl9UnAAC/BwI6AKBKGzBggJ577jlt27ZN8+fP17XXXqt27dpZ2xs1aqSTJ09aZ8x/qwYNGkg6dwb4fHv27HH7+Z///Kf8/f21cuVK+fn5WfV58+aVeqzD4VDXrl3VtWtXvfzyy3rxxRf1pz/9SV988cVFey+rl71796p69eoKCwuTJFWvXr1Uf5K0e/duORwORUVF/epzVFT9+vXVqVMnrV27VsOGDXML2udr1KiRJKlOnToV+rtp1KiRnnzyST355JPat2+fWrVqpf/+7//W3//+9yvSNwAAVwKXuAMAqrSSs+UTJ07U1q1bS333+f3336+UlBStXLmy1GOzs7NVVFR0Sc9Xt25dtWrVSu+9957bZeqrVq3Srl273NY6nU4ZhqHi4mKrduDAAS1atMht3bFjx0o9T6tWrSRJBQUFF+0pJSXF7TPtP//8sxYvXqwePXrI6XTK6XSqR48eWrx4sdvn9TMzMzV//nzdeOONCgoKuujzVNSUKVM0adIkjRw5stw1CQkJCgoK0osvvqgzZ86U2p6VlSVJys/P1+nTp922NWrUSDVr1qzQawMAwB+JM+gAgCotOjpaHTt21OLFiyWpVEB/+umn9emnn+r222/XoEGDFBcXp7y8PG3fvl0ff/yxDhw4oNq1a1/Sc06dOlWJiYm68cYb9cgjj+jYsWN644031KxZM7evEUtMTNTLL7+snj176oEHHtDhw4c1e/ZsNW7cWNu2bbPWvfDCC1q/fr0SExPVoEEDHT58WHPmzFFkZKRuvPHGi/bTvHlzJSQkuH3NmiRNnjzZWjNlyhTru9Yff/xx+fj46K233lJBQYFmzJhxSfNfTOfOndW5c+dfXRMUFKQ333xTDz30kNq0aaN+/fopLCxMBw8e1NKlS9WpUyfNmjVLe/fuVdeuXXX//fcrNjZWPj4++uSTT5SZmal+/fpd0b4BAPitCOgAgCpvwIAB2rBhg9q3b6/GjRu7batevbrWrVunF198UQsXLtTf/vY3BQUFqUmTJpo8ebLbndgrqmfPnlq4cKGeffZZTZgwQY0aNdK8efO0ePFirV271lp366236n/+5380bdo0jRo1StHR0Zo+fboOHDjgFtB79+6tAwcO6N1339WRI0dUu3Ztde7cucL9de7cWfHx8Zo8ebIOHjyo2NhYJScnq0WLFtaaZs2a6csvv9SECRM0depUuVwudejQQX//+9+t70D/oz3wwAOqV6+epk2bppkzZ6qgoEBXX321brrpJiUlJUk6+z3y/fv31+rVq/X+++/Lx8dHTZs21UcffaQ+ffp4pG8AAMpjmJdz1xoAAFApGIah4cOHa9asWZ5uBQCAKo/PoAMAAAAAYAMEdAAAAAAAbICADgAAAACADXCTOAAAqjBuRQMAgH1wBh0AAAAAABsgoAMAAAAAYANc4l7FuFwupaenq2bNmjIMw9PtAAAAAPAQ0zR14sQJ1atXTw4H527tgIBexaSnpysqKsrTbQAAAACwiZ9//lmRkZGebgMioFc5NWvWlHT2TRgUFOThbgAAAAB4Sm5urqKioqyMAM8joFcxJZe1BwUFEdABAAAA8NFXG+GDBgAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZQ5QP6888/L8Mw3P40bdrU2n769GkNHz5coaGhqlGjhvr06aPMzEy3fRw8eFCJiYmqXr266tSpo6efflpFRUVua9auXas2bdrIz89PjRs3VnJycqleZs+erYYNG8rf318dOnTQxo0b3bZXpBcAAAAAgHeq8gFdkpo1a6ZffvnF+vPVV19Z20aPHq3PPvtMCxcu1Lp165Senq577rnH2l5cXKzExEQVFhZqw4YNeu+995ScnKyJEydaa9LS0pSYmKguXbpo69atGjVqlIYMGaKVK1daaxYsWKAxY8Zo0qRJ2rJli1q2bKmEhAQdPny4wr0AAAAAALyXYZqm6ekmPOn555/XokWLtHXr1lLbcnJyFBYWpvnz5+vee++VJO3evVsxMTFKSUnRDTfcoOXLl+v2229Xenq6wsPDJUlz587VuHHjlJWVJV9fX40bN05Lly7Vjh07rH3369dP2dnZWrFihSSpQ4cOateunWbNmiVJcrlcioqK0siRIzV+/PgK9VIRubm5Cg4OVk5OjoKCgi77dQMAAADg3cgG9uPj6QbsYN++fapXr578/f0VHx+vqVOnqn79+tq8ebPOnDmjbt26WWubNm2q+vXrW6E4JSVF119/vRXOJSkhIUHDhg3Tzp071bp1a6WkpLjto2TNqFGjJEmFhYXavHmzJkyYYG13OBzq1q2bUlJSJKlCvZSloKBABQUF1s+5ubmSpKKiIusyfIfDIYfDIZfLJZfL5daDw+FQcXGxzv89Tnl1p9MpwzBKXd7vdDolnb3aoCJ1Hx8fmabpVjcMQ06ns1SP5dWZiZmYiZmYiZmYiZmYiZmY6ddnunA7PK/KB/QOHTooOTlZ1113nX755RdNnjxZN910k3bs2KGMjAz5+voqJCTE7THh4eHKyMiQJGVkZLiF85LtJdt+bU1ubq5OnTql48ePq7i4uMw1u3fvtvZxsV7KMnXqVE2ePLlUPTU1VYGBgZKksLAwNWrUSGlpacrKyrLWREZGKjIyUnv37lVOTo5Vv+aaa1SnTh3t2LFDp06dsupNmzZVSEiIUlNT3f7F1KJFC/n6+mrTpk1uPbRt21aFhYXatm2bVXM6nWrXrp1ycnKs2SUpICBALVu21JEjR7R//36rHhwcrJiYGKWnp+vQoUNWnZmYiZmYiZmYiZmY6UrNtPr7sx853HLU0OYjDvWKKlZk9XO9rM8wtCfHofuiixXie66+/JBDh/IMDbq2WNXO+2Dpx2kOnSySBl17LoBJUvI+h2r4SPdGn6ufcUnJ+5yKDDTVK/JcPbtQWpjm1HXBLt0ccS6YHcqXlv/sVFxtl9qEnqvvyTG0PsOhmyNcui74XJ2ZPDPTPTdca4v3U15enmAvVf4S9wtlZ2erQYMGevnllxUQEKCkpCS3M9CS1L59e3Xp0kXTp0/XY489pp9++snt8+T5+fkKDAzUsmXL1KtXLzVp0kRJSUluZ8iXLVumxMRE5efn6/jx47r66qu1YcMGxcfHW2vGjh2rdevW6ZtvvtH8+fMv2ktZyjqDHhUVpaNHj1qXsfDbR2ZiJmZiJmZiJmZipvJnipl49iOJxabkMg35GKYM49xzFrskl0rXi1ySKUPVHO7/u322LrcwKJ0NeYYkn1J1Q4ZMt7ppSkWmIYdMOcuqG6ac5/XiMqVi05DTMOU4v3dm8shMu//cyxbvp9zcXIWGhnKJu41U+TPoFwoJCVGTJk30ww8/qHv37iosLFR2drbbmevMzExFRERIkiIiIkrdbb3kzurnr7nwbuuZmZkKCgpSQECAnE6nnE5nmWvO38fFeimLn5+f/Pz8StV9fHzk4+P+11/yBr9QyRu5ovUL93s5dcMwyqyX1+Ol1pmJmcqrMxMzScxUXo+XWmcmZpIqx0xnXIZbvcg0zia3C5RXv/Dx5+qla2a5daPMukuGXGXVTUOuMnopNg0VX0LvzPT7zFRy/Hv6/VTedngOd3G/wMmTJ/Xjjz+qbt26iouLU7Vq1bR69Wpr+549e3Tw4EHrTHd8fLy2b9/udrf1VatWKSgoSLGxsdaa8/dRsqZkH76+voqLi3Nb43K5tHr1amtNRXoBAAAAAHivKv8rk6eeekp33HGHGjRooPT0dE2aNElOp1P9+/dXcHCwBg8erDFjxqhWrVoKCgrSyJEjFR8fb92UrUePHoqNjdVDDz2kGTNmKCMjQ88++6yGDx9unbkeOnSoZs2apbFjx+qRRx7RmjVr9NFHH2np0qVWH2PGjNHAgQPVtm1btW/fXq+++qry8vKUlJQkSRXqBQAAAADgvap8QD906JD69++vo0ePKiwsTDfeeKO+/vprhYWFSZJeeeUVORwO9enTRwUFBUpISNCcOXOsxzudTi1ZskTDhg1TfHy8AgMDNXDgQL3wwgvWmujoaC1dulSjR4/Wa6+9psjISL3zzjtKSEiw1vTt21dZWVmaOHGiMjIy1KpVK61YscLtxnEX6wUAAAAA4L24SVwVw3cdAgAAXJqG45defBFwCQ5MS/R0C5LIBnbEZ9ABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgn2fatGkyDEOjRo2yaqdPn9bw4cMVGhqqGjVqqE+fPsrMzHR73MGDB5WYmKjq1aurTp06evrpp1VUVOS2Zu3atWrTpo38/PzUuHFjJScnl3r+2bNnq2HDhvL391eHDh20ceNGt+0V6QUAAAAA4J0I6P/n22+/1VtvvaUWLVq41UePHq3PPvtMCxcu1Lp165Senq577rnH2l5cXKzExEQVFhZqw4YNeu+995ScnKyJEydaa9LS0pSYmKguXbpo69atGjVqlIYMGaKVK1daaxYsWKAxY8Zo0qRJ2rJli1q2bKmEhAQdPny4wr0AAAAAALyXYZqm6ekmPO3kyZNq06aN5syZoylTpqhVq1Z69dVXlZOTo7CwMM2fP1/33nuvJGn37t2KiYlRSkqKbrjhBi1fvly333670tPTFR4eLkmaO3euxo0bp6ysLPn6+mrcuHFaunSpduzYYT1nv379lJ2drRUrVkiSOnTooHbt2mnWrFmSJJfLpaioKI0cOVLjx4+vUC8VkZubq+DgYOXk5CgoKOiKvYYAAACVVcPxSz3dAiqZA9MSPd2CJLKBHfl4ugE7GD58uBITE9WtWzdNmTLFqm/evFlnzpxRt27drFrTpk1Vv359KxSnpKTo+uuvt8K5JCUkJGjYsGHauXOnWrdurZSUFLd9lKwpuZS+sLBQmzdv1oQJE6ztDodD3bp1U0pKSoV7KUtBQYEKCgqsn3NzcyVJRUVF1mX4DodDDodDLpdLLpfLrQeHw6Hi4mKd/3uc8upOp1OGYZS6vN/pdEo6e7VBReo+Pj4yTdOtbhiGnE5nqR7LqzMTMzETMzETMzETM12pmao5zvZZbEou05CPYcowzj1nsUtyqXS9yCWZMqzHu9elahdcy3rGJRmSfErVDRky3eqmKRWZhhwy5SyrbphynteLy5SKTUNOw5Tj/N6ZySMzFRcX2+L9dOF2eF6VD+j/+Mc/tGXLFn377beltmVkZMjX11chISFu9fDwcGVkZFhrzg/nJdtLtv3amtzcXJ06dUrHjx9XcXFxmWt2795d4V7KMnXqVE2ePLlUPTU1VYGBgZKksLAwNWrUSGlpacrKyrLWREZGKjIyUnv37lVOTo5Vv+aaa1SnTh3t2LFDp06dsupNmzZVSEiIUlNT3f6j2KJFC/n6+mrTpk1uPbRt21aFhYXatm2bVXM6nWrXrp1ycnKs2SUpICBALVu21JEjR7R//36rHhwcrJiYGKWnp+vQoUNWnZmYiZmYiZmYiZmY6UrNNOjas0Fpy1FDm48Y6h7pUmT1c72szzC0J8fQ3Q1dCvE9V19+yKFDedKARi63kPdxmkMni2Ttt0TyPodq+Ej3Rp+rn3FJyfucujpQ6hV5rp5dKC1Mc+raYFM3R5wLZofypeU/O9U61FSb0HP1PTmG1mcY6hRu6rrgc3Vm8sxMe/futcX7KS8vT7CXKn2J+88//6y2bdtq1apV1mfPb7nlFusS9/nz5yspKcntDLQktW/fXl26dNH06dP12GOP6aeffnL7PHl+fr4CAwO1bNky9erVS02aNFFSUpLbGfJly5YpMTFR+fn5On78uK6++mpt2LBB8fHx1pqxY8dq3bp1+uabbyrUS1nKOoMeFRWlo0ePWpexVIXffDMTMzETMzETMzETM13uTDETz34k0RvOzFbGs82Vcabdf+5li/dTbm6uQkNDucTdRqr0GfTNmzfr8OHDatOmjVUrLi7W+vXrNWvWLK1cuVKFhYXKzs52O3OdmZmpiIgISVJERESpu62X3Fn9/DUX3m09MzNTQUFBCggIkNPplNPpLHPN+fu4WC9l8fPzk5+fX6m6j4+PfHzc//pL3uAXKnkjV7R+4X4vp24YRpn18nq81DozMVN5dWZiJomZyuvxUuvMxExS5ZjpjMtwqxeZxtnkdoHy6hc+/ly9dM0st26UWXfJkKusumnIVUYvxaah4kvonZl+n5lKjn9Pv5/K2w7PqdJ3ce/atau2b9+urVu3Wn/atm2rAQMGWP9crVo1rV692nrMnj17dPDgQetMd3x8vLZv3+52t/VVq1YpKChIsbGx1prz91GypmQfvr6+iouLc1vjcrm0evVqa01cXNxFewEAAAAAeK8q/SuTmjVrqnnz5m61wMBAhYaGWvXBgwdrzJgxqlWrloKCgjRy5EjFx8dbN2Xr0aOHYmNj9dBDD2nGjBnKyMjQs88+q+HDh1tnrocOHapZs2Zp7NixeuSRR7RmzRp99NFHWrr03B1Bx4wZo4EDB6pt27Zq3769Xn31VeXl5SkpKUnS2c9IXawXAAAAAID3qtIBvSJeeeUVORwO9enTRwUFBUpISNCcOXOs7U6nU0uWLNGwYcMUHx+vwMBADRw4UC+88IK1Jjo6WkuXLtXo0aP12muvKTIyUu+8844SEhKsNX379lVWVpYmTpyojIwMtWrVSitWrHC7cdzFegEAAAAAeK8qfZO4qojvOgQAALg0fA86rjS+Bx3lqdKfQQcAAAAAwC4I6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2ICPpxu4VNnZ2frkk0/05Zdf6qefflJ+fr7CwsLUunVrJSQkqGPHjp5uEQAAAACAS+Y1Z9DT09M1ZMgQ1a1bV1OmTNGpU6fUqlUrde3aVZGRkfriiy/UvXt3xcbGasGCBZ5uFwAAAACAS+I1Z9Bbt26tgQMHavPmzYqNjS1zzalTp7Ro0SK9+uqr+vnnn/XUU0/9wV0CAAAAAHB5vOYM+q5duzRjxoxyw7kkBQQEqH///kpJSVFSUlKF9vvmm2+qRYsWCgoKUlBQkOLj47V8+XJr++nTpzV8+HCFhoaqRo0a6tOnjzIzM932cfDgQSUmJqp69eqqU6eOnn76aRUVFbmtWbt2rdq0aSM/Pz81btxYycnJpXqZPXu2GjZsKH9/f3Xo0EEbN250216RXgAAAAAA3slrAnpoaOjvsj4yMlLTpk3T5s2btWnTJt1666268847tXPnTknS6NGj9dlnn2nhwoVat26d0tPTdc8991iPLy4uVmJiogoLC7Vhwwa99957Sk5O1sSJE601aWlpSkxMVJcuXbR161aNGjVKQ4YM0cqVK601CxYs0JgxYzRp0iRt2bJFLVu2VEJCgg4fPmytuVgvAAAAAADvZZimaXq6id/q+++/19dff63WrVurVatWv3l/tWrV0syZM3XvvfcqLCxM8+fP17333itJ2r17t2JiYpSSkqIbbrhBy5cv1+2336709HSFh4dLkubOnatx48YpKytLvr6+GjdunJYuXaodO3ZYz9GvXz9lZ2drxYoVkqQOHTqoXbt2mjVrliTJ5XIpKipKI0eO1Pjx45WTk3PRXioiNzdXwcHBysnJUVBQ0G9+rQAAACq7huOXeroFVDIHpiV6ugVJZAM78prPoJd44YUXFBAQoKefflqS9MUXX6hnz56qWbOmcnJylJycrAEDBlzWvouLi7Vw4ULl5eUpPj5emzdv1pkzZ9StWzdrTdOmTVW/fn0rFKekpOj666+3wrkkJSQkaNiwYdq5c6dat26tlJQUt32UrBk1apQkqbCwUJs3b9aECROs7Q6HQ926dVNKSookVaiXshQUFKigoMD6OTc3V5JUVFRkXYbvcDjkcDjkcrnkcrncenA4HCouLtb5v8cpr+50OmUYRqnL+51Op/X6VqTu4+Mj0zTd6oZhyOl0luqxvDozMRMzMRMzMRMzMdOVmqma42yfxabkMg35GKYM49xzFrskl0rXi1ySKcN6vHtdqnbBtaxnXJIhyadU3ZAh061umlKRacghU86y6oYp53m9uEyp2DTkNEw5zu+dmTwyU3FxsS3eTxduh+d5XUD/+OOPNXXqVOvnv/zlL3riiSc0c+ZMvfXWW3rxxRcvOaBv375d8fHxOn36tGrUqKFPPvlEsbGx2rp1q3x9fRUSEuK2Pjw8XBkZGZKkjIwMt3Besr1k26+tyc3N1alTp3T8+HEVFxeXuWb37t3WPi7WS1mmTp2qyZMnl6qnpqYqMDBQkhQWFqZGjRopLS1NWVlZ1prIyEhFRkZq7969ysnJserXXHON6tSpox07dujUqVNWvWnTpgoJCVFqaqrbfxRbtGghX19fbdq0ya2Htm3bqrCwUNu2bbNqTqdT7dq1U05OjjW7dPb+Ai1bttSRI0e0f/9+qx4cHKyYmBilp6fr0KFDVp2ZmImZmImZmImZmOlKzTTo2rNBactRQ5uPGOoe6VJk9XO9rM8wtCfH0N0NXQrxPVdffsihQ3nSgEYut5D3cZpDJ4tk7bdE8j6HavhI90afq59xScn7nLo6UOoVea6eXSgtTHPq2mBTN0ecC2aH8qXlPzvVOtRUm9Bz9T05htZnGOoUbuq64HN1ZvLMTHv37rXF+ykvL0+wF6+5xP1vf/ubTNPUyJEjNW7cOEVFRck0TQ0dOlTjx49XdHS08vLyNGbMGL311luSpIcffrhC+y4sLNTBgweVk5Ojjz/+WO+8847WrVunrVu3Kikpye0MtCS1b99eXbp00fTp0/XYY4/pp59+cvs8eX5+vgIDA7Vs2TL16tVLTZo0UVJSktsZ8mXLlikxMVH5+fk6fvy4rr76am3YsEHx8fHWmrFjx2rdunX65ptvNH/+/Iv2UpayzqBHRUXp6NGj1mUsVeE338zETMzETMzETMzETJc7U8zEsx9J9IYzs5XxbHNlnGn3n3vZ4v2Um5ur0NBQLnG3Ea85g96gQQNJkq+vr8LDw9WgQQNt3bpVQUFB6tKli0zTVEFBgQzDUMOGDd0O0Ivx9fVV48aNJUlxcXH69ttv9dprr6lv374qLCxUdna225nrzMxMRURESJIiIiJK3W295M7q56+58G7rmZmZCgoKUkBAgJxOp5xOZ5lrzt/HxXopi5+fn/z8/ErVfXx85OPj/tdf8ga/UMkbuaL1C/d7OXXDMMqsl9fjpdaZiZnKqzMTM0nMVF6Pl1pnJmaSKsdMZ1yGW73INM4mtwuUV7/w8efqpWtmuXWjzLpLhlxl1U1DrjJ6KTYNFV9C78z0+8xUcvx7+v1U3nZ4jtfcxb1z587q3Lmz2rRpoyVLlsjX11crVqzQbbfdpptvvlmdO3dW3bp1FRUVZf18uVwulwoKChQXF6dq1app9erV1rY9e/bo4MGD1pnu+Ph4bd++3e1u66tWrVJQUJD1lXDx8fFu+yhZU7IPX19fxcXFua1xuVxavXq1taYivQAAAAAAvJfX/cpk5syZuvPOO9WpUyc1bdpUb7/9trUtOTlZPXv2vKT9TZgwQb169VL9+vV14sQJzZ8/X2vXrtXKlSsVHByswYMHa8yYMapVq5aCgoI0cuRIxcfHWzdl69Gjh2JjY/XQQw9pxowZysjI0LPPPqvhw4dbZ66HDh2qWbNmaezYsXrkkUe0Zs0affTRR1q69NwdQceMGaOBAweqbdu2at++vV599VXl5eVZ3+dekV4AAAAAAN7L6wJ6y5YtdeDAAR09erTUd50/9dRTl/zZicOHD+vhhx/WL7/8ouDgYLVo0UIrV65U9+7dJUmvvPKKHA6H+vTpo4KCAiUkJGjOnDnW451Op5YsWaJhw4YpPj5egYGBGjhwoF544QVrTXR0tJYuXarRo0frtddeU2RkpN555x0lJCRYa/r27ausrCxNnDhRGRkZatWqlVasWOF247iL9QIAAAAA8F5ec5O4ivrPf/6jq6++2tNt2BbfdQgAAHBp+B50XGl8DzrK4zWfQb+YjIwMjRw5Utdee62nWwEAAAAA4JJ5VUA/fvy4+vfvr9q1a6tevXp6/fXX5XK5NHHiRF1zzTX69ttvNW/ePE+3CQAAAADAJfOqz6CPHz9eGzZs0KBBg7Ry5UqNHj1aK1askMPh0Jo1a7hZGgAAAADAa3nVGfTly5dr3rx5eumll/TZZ5/JNE21atVKS5YsIZwDAAAAALyaVwX09PR0xcTESJIaNmwof39/Pfjggx7uCgAAAACA386rArppmvLxOXdVvtPpVEBAgAc7AgAAAADgyvCqz6CbpqmuXbtaIf3UqVO644475Ovr67Zuy5YtnmgPAAAAAIDL5lUBfdKkSW4/33nnnR7qBAAAAACAK8urAzoAAAAAAJWFV30GHQAAAACAysprAnrPnj319ddfX3TdiRMnNH36dM2ePfsP6AoAAAAAgCvDay5xv++++9SnTx8FBwfrjjvuUNu2bVWvXj35+/vr+PHj2rVrl7766istW7ZMiYmJmjlzpqdbBgAAAACgwrwmoA8ePFgPPvigFi5cqAULFujtt99WTk6OJMkwDMXGxiohIUHffvut9V3pAAAAAAB4C68J6JLk5+enBx98UA8++KAkKScnR6dOnVJoaKiqVavm4e4AAAAAALh8XhXQLxQcHKzg4GBPtwEAAAAAwG/mNTeJAwAAAACgMiOgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANeGVA//nnn3Xo0CHr540bN2rUqFF6++23PdgVAAAAAACXzysD+gMPPKAvvvhCkpSRkaHu3btr48aN+tOf/qQXXnjBw90BAAAAAHDpvDKg79ixQ+3bt5ckffTRR2revLk2bNigDz74QMnJyZ5tDgAAAACAy+CVAf3MmTPy8/OTJP3rX/9S7969JUlNmzbVL7/84snWAAAAAAC4LF4Z0Js1a6a5c+fqyy+/1KpVq9SzZ09JUnp6ukJDQz3cHQAAAAAAl84rA/r06dP11ltv6ZZbblH//v3VsmVLSdKnn35qXfoOAAAAAIA38fF0A5fjlltu0ZEjR5Sbm6urrrrKqj/22GOqXr26BzsDAAAAAODyeGVAlySn0+kWziWpYcOGnmkGAAAAAIDfyGsD+scff6yPPvpIBw8eVGFhodu2LVu2eKgrAAAAAAAuj1d+Bv31119XUlKSwsPDlZqaqvbt2ys0NFT79+9Xr169PN0eAAAAAACXzCsD+pw5c/T222/rjTfekK+vr8aOHatVq1bpiSeeUE5OjqfbAwAAAADgknllQD948KA6duwoSQoICNCJEyckSQ899JA+/PBDT7YGAAAAAMBl8cqAHhERoWPHjkmS6tevr6+//lqSlJaWJtM0PdkaAAAAAACXxSsD+q233qpPP/1UkpSUlKTRo0ere/fu6tu3r+6++24PdwcAAAAAwKXzyru4v/3223K5XJKk4cOHKzQ0VBs2bFDv3r31X//1Xx7uDgAAAACAS+eVAd3hcMjhOHfyv1+/furXr58HOwIAAAAA4LfxmoC+bdu2Cq9t0aLF79gJAAAAAABXntcE9FatWskwDJmmKcMwfnVtcXHxH9QVAAAAAABXhtfcJC4tLU379+9XWlqa/vnPfyo6Olpz5sxRamqqUlNTNWfOHDVq1Ej//Oc/Pd0qAAAAAACXzGvOoDdo0MD65/vuu0+vv/66brvtNqvWokULRUVF6bnnntNdd93lgQ4BAAAAALh8XnMG/Xzbt29XdHR0qXp0dLR27drlgY4AAAAAAPhtvDKgx8TEaOrUqSosLLRqhYWFmjp1qmJiYjzYGQAAAAAAl8drLnE/39y5c3XHHXcoMjLSumP7tm3bZBiGPvvsMw93BwAAAADApfPKgN6+fXvt379fH3zwgXbv3i1J6tu3rx544AEFBgZ6uDsAAAAAAC6dVwZ0SQoMDNRjjz3m6TYAAAAAALgivDag79u3T1988YUOHz4sl8vltm3ixIke6goAAAAAgMvjlQH9r3/9q4YNG6batWsrIiJChmFY2wzDIKADAAAAALyOVwb0KVOm6C9/+YvGjRvn6VYAAAAAALgivPJr1o4fP6777rvP020AAAAAAHDFeGVAv++++/T55597ug0AAAAAAK4Yr7zEvXHjxnruuef09ddf6/rrr1e1atXctj/xxBMe6gwAAAAAgMtjmKZperqJSxUdHV3uNsMwtH///j+wG++Sm5ur4OBg5eTkKCgoyNPtAAAA2F7D8Us93QIqmQPTEj3dgiSygR155Rn0tLQ0T7cAAAAAAMAV5ZWfQS9RWFioPXv2qKioyNOtAAAAAADwm3hlQM/Pz9fgwYNVvXp1NWvWTAcPHpQkjRw5UtOmTfNwdwAAAAAAXDqvDOgTJkzQd999p7Vr18rf39+qd+vWTQsWLPBgZwAAAAAAXB6v/Az6okWLtGDBAt1www0yDMOqN2vWTD/++KMHOwMAAAAA4PJ45Rn0rKws1alTp1Q9Ly/PLbADAAAAAOAtvDKgt23bVkuXnvu6i5JQ/s477yg+Pt5TbQEAAAAAcNm88hL3F198Ub169dKuXbtUVFSk1157Tbt27dKGDRu0bt06T7cHAAAAAMAl86oz6Dt27JAk3Xjjjdq6dauKiop0/fXX6/PPP1edOnWUkpKiuLg4D3cJAAAAAMCl86oz6C1atFC7du00ZMgQ9evXT3/961893RIAAAAAAFeEV51BX7dunZo1a6Ynn3xSdevW1aBBg/Tll196ui0AAAAAAH4zrwroN910k95991398ssveuONN5SWlqbOnTurSZMmmj59ujIyMjzdIgAAAAAAl8WrAnqJwMBAJSUlad26ddq7d6/uu+8+zZ49W/Xr11fv3r093R4AAAAAAJfMKwP6+Ro3bqxnnnlGzz77rGrWrOn29WsAAAAAAHgLr7pJ3IXWr1+vd999V//85z/lcDh0//33a/DgwZ5uCwAAAACAS+Z1AT09PV3JyclKTk7WDz/8oI4dO+r111/X/fffr8DAQE+3BwAAAADAZfGqgN6rVy/961//Uu3atfXwww/rkUce0XXXXefptgAAAAAA+M28KqBXq1ZNH3/8sW6//XY5nU5PtwMAAAAAwBXjVQH9008/9XQLAAAAAAD8Lrz+Lu4AAAAAAFQGBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYQJUP6FOnTlW7du1Us2ZN1alTR3fddZf27Nnjtub06dMaPny4QkNDVaNGDfXp00eZmZluaw4ePKjExERVr15dderU0dNPP62ioiK3NWvXrlWbNm3k5+enxo0bKzk5uVQ/s2fPVsOGDeXv768OHTpo48aNl9wLAAAAAMD7VPmAvm7dOg0fPlxff/21Vq1apTNnzqhHjx7Ky8uz1owePVqfffaZFi5cqHXr1ik9PV333HOPtb24uFiJiYkqLCzUhg0b9N577yk5OVkTJ0601qSlpSkxMVFdunTR1q1bNWrUKA0ZMkQrV6601ixYsEBjxozRpEmTtGXLFrVs2VIJCQk6fPhwhXsBAAAAAHgnwzRN09NN2ElWVpbq1KmjdevW6eabb1ZOTo7CwsI0f/583XvvvZKk3bt3KyYmRikpKbrhhhu0fPly3X777UpPT1d4eLgkae7cuRo3bpyysrLk6+urcePGaenSpdqxY4f1XP369VN2drZWrFghSerQoYPatWunWbNmSZJcLpeioqI0cuRIjR8/vkK9XExubq6Cg4OVk5OjoKCgK/raAQAAVEYNxy/1dAuoZA5MS/R0C5LIBnbk4+kG7CYnJ0eSVKtWLUnS5s2bdebMGXXr1s1a07RpU9WvX98KxSkpKbr++uutcC5JCQkJGjZsmHbu3KnWrVsrJSXFbR8la0aNGiVJKiws1ObNmzVhwgRru8PhULdu3ZSSklLhXi5UUFCggoIC6+fc3FxJUlFRkXUJvsPhkMPhkMvlksvlcnt+h8Oh4uJinf97nPLqTqdThmGUurTf6XRKOnulQUXqPj4+Mk3TrW4YhpxOZ6key6szEzMxEzMxEzMxEzNdqZmqOc72WWxKLtOQj2HKMM49Z7FLcql0vcglmTKsx7vXpWoXXMt6xiUZknxK1Q0ZMt3qpikVmYYcMuUsq26Ycp7Xi8uUik1DTsOU4/zemckjMxUXF9vi/XThdngeAf08LpdLo0aNUqdOndS8eXNJUkZGhnx9fRUSEuK2Njw8XBkZGdaa88N5yfaSbb+2Jjc3V6dOndLx48dVXFxc5prdu3dXuJcLTZ06VZMnTy5VT01NVWBgoCQpLCxMjRo1UlpamrKysqw1kZGRioyM1N69e61fXEjSNddcozp16mjHjh06deqUVW/atKlCQkKUmprq9h/FFi1ayNfXV5s2bXLroW3btiosLNS2bdusmtPpVLt27ZSTk2PNLUkBAQFq2bKljhw5ov3791v14OBgxcTEKD09XYcOHbLqzMRMzMRMzMRMzMRMV2qmQdeeDUpbjhrafMRQ90iXIquf62V9hqE9OYbubuhSiO+5+vJDDh3KkwY0crmFvI/THDpZJGu/JZL3OVTDR7o3+lz9jEtK3ufU1YFSr8hz9exCaWGaU9cGm7o54lwwO5QvLf/ZqdahptqEnqvvyTG0PsNQp3BT1wWfqzOTZ2bau3evLd5P53+sF/bAJe7nGTZsmJYvX66vvvpKkZGRkqT58+crKSnJ7Sy0JLVv315dunTR9OnT9dhjj+mnn35y+zx5fn6+AgMDtWzZMvXq1UtNmjRRUlKS2xnyZcuWKTExUfn5+Tp+/LiuvvpqbdiwQfHx8daasWPHat26dfrmm28q1MuFyjqDHhUVpaNHj1qXsVSF33wzEzMxEzMxEzMxEzNd7kwxE89+HNEbzsxWxrPNlXGm3X/uZYv3U25urkJDQ7nE3UY4g/5/RowYoSVLlmj9+vVWOJekiIgIFRYWKjs72+3MdWZmpiIiIqw1F95tveTO6uevufBu65mZmQoKClJAQICcTqecTmeZa87fx8V6uZCfn5/8/PxK1X18fOTj4/7XX/IGv1DJG7mi9Qv3ezl1wzDKrJfX46XWmYmZyqszEzNJzFRej5daZyZmkirHTGdchlu9yDTOJrcLlFe/8PHn6qVrZrl1o8y6S4ZcZdVNQ64yeik2DRVfQu/M9PvMVHL8e/r9VN52eE6Vv4u7aZoaMWKEPvnkE61Zs0bR0dFu2+Pi4lStWjWtXr3aqu3Zs0cHDx60znTHx8dr+/btbndbX7VqlYKCghQbG2utOX8fJWtK9uHr66u4uDi3NS6XS6tXr7bWVKQXAAAAAIB3qvK/Mhk+fLjmz5+vxYsXq2bNmtZnuYODgxUQEKDg4GANHjxYY8aMUa1atRQUFKSRI0cqPj7euilbjx49FBsbq4ceekgzZsxQRkaGnn32WQ0fPtw6ez106FDNmjVLY8eO1SOPPKI1a9boo48+0tKl5+4KOmbMGA0cOFBt27ZV+/bt9eqrryovL09JSUlWTxfrBQAAAADgnap8QH/zzTclSbfccotbfd68eRo0aJAk6ZVXXpHD4VCfPn1UUFCghIQEzZkzx1rrdDq1ZMkSDRs2TPHx8QoMDNTAgQP1wgsvWGuio6O1dOlSjR49Wq+99poiIyP1zjvvKCEhwVrTt29fZWVlaeLEicrIyFCrVq20YsUKtxvHXawXAAAAAIB34iZxVQzfdQgAAHBp+B50XGl8DzrKU+U/gw4AAAAAgB0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAAAAANkBABwAAAADABgjoAAAAAADYQJUP6OvXr9cdd9yhevXqyTAMLVq0yG27aZqaOHGi6tatq4CAAHXr1k379u1zW3Ps2DENGDBAQUFBCgkJ0eDBg3Xy5Em3Ndu2bdNNN90kf39/RUVFacaMGaV6WbhwoZo2bSp/f39df/31WrZs2SX3AgAAAADwTlU+oOfl5ally5aaPXt2mdtnzJih119/XXPnztU333yjwMBAJSQk6PTp09aaAQMGaOfOnVq1apWWLFmi9evX67HHHrO25+bmqkePHmrQoIE2b96smTNn6vnnn9fbb79trdmwYYP69++vwYMHKzU1VXfddZfuuusu7dix45J6AQAAAAB4J8M0TdPTTdiFYRj65JNPdNddd0k6e8a6Xr16evLJJ/XUU09JknJychQeHq7k5GT169dP33//vWJjY/Xtt9+qbdu2kqQVK1botttu06FDh1SvXj29+eab+tOf/qSMjAz5+vpKksaPH69FixZp9+7dkqS+ffsqLy9PS5Yssfq54YYb1KpVK82dO7dCvVREbm6ugoODlZOTo6CgoCvyugEAAFRmDccv9XQLqGQOTEv0dAuSyAZ25OPpBuwsLS1NGRkZ6tatm1ULDg5Whw4dlJKSon79+iklJUUhISFWOJekbt26yeFw6JtvvtHdd9+tlJQU3XzzzVY4l6SEhARNnz5dx48f11VXXaWUlBSNGTPG7fkTEhKsS+4r0ktZCgoKVFBQYP2cm5srSSoqKlJRUZEkyeFwyOFwyOVyyeVyWWtL6sXFxTr/9zjl1Z1OpwzDsPZ7fl2SiouLK1T38fGRaZpudcMw5HQ6S/VYXp2ZmImZmImZmImZmOlKzVTNcbbPYlNymYZ8DFOGce45i12SS6XrRS7JlGE93r0uVbvgWtYzLsmQ5FOqbsiQ6VY3TanINOSQKWdZdcOU87xeXKZUbBpyGqYc5/fOTB6Zqbi42Bbvpwu3w/MI6L8iIyNDkhQeHu5WDw8Pt7ZlZGSoTp06btt9fHxUq1YttzXR0dGl9lGy7aqrrlJGRsZFn+divZRl6tSpmjx5cql6amqqAgMDJUlhYWFq1KiR0tLSlJWVZa2JjIxUZGSk9u7dq5ycHKt+zTXXqE6dOtqxY4dOnTpl1Zs2baqQkBClpqa6/UexRYsW8vX11aZNm9x6aNu2rQoLC7Vt2zar5nQ61a5dO+Xk5FhXF0hSQECAWrZsqSNHjmj//v1WPTg4WDExMUpPT9ehQ4esOjMxEzMxEzMxEzMx05WaadC1Z4PSlqOGNh8x1D3Spcjq53pZn2FoT46huxu6FHLufIyWH3LoUJ40oJHLLeR9nObQySJZ+y2RvM+hGj7SvdHn6mdcUvI+p64OlHpFnqtnF0oL05y6NtjUzRHngtmhfGn5z061DjXVJvRcfU+OofUZhjqFm7ou+FydmTwz0969e23xfsrLyxPshUvcz3PhJe4bNmxQp06dlJ6errp161rr7r//fhmGoQULFujFF1/Ue++9pz179rjtq06dOpo8ebKGDRumHj16KDo6Wm+99Za1fdeuXWrWrJl27dqlmJgY+fr66r333lP//v2tNXPmzNHkyZOVmZlZoV7KUtYZ9KioKB09etS6jKUq/OabmZiJmZiJmZiJmZjpcmeKmbji7HN5wZnZyni2uTLOtPvPvWzxfsrNzVVoaCiXuNsIZ9B/RUREhCQpMzPTLRRnZmaqVatW1prDhw+7Pa6oqEjHjh2zHh8REaHMzEy3NSU/X2zN+dsv1ktZ/Pz85OfnV6ru4+MjHx/3v/6SN/iFSt7IFa1fuN/LqRuGUWa9vB4vtc5MzFRenZmYSWKm8nq81DozMZNUOWY64zLc6kWmcTa5XaC8+oWPP1cvXTPLrRtl1l0y5CqrbhpyldFLsWmo+BJ6Z6bfZ6aS49/T76fytsNzqvxd3H9NdHS0IiIitHr1aquWm5urb775RvHx8ZKk+Ph4ZWdna/PmzdaaNWvWyOVyqUOHDtaa9evX68yZM9aaVatW6brrrtNVV11lrTn/eUrWlDxPRXoBAAAAAHivKh/QT548qa1bt2rr1q2Szt6MbevWrTp48KAMw9CoUaM0ZcoUffrpp9q+fbsefvhh1atXz7oMPiYmRj179tSjjz6qjRs36t///rdGjBihfv36qV69epKkBx54QL6+vho8eLB27typBQsW6LXXXnO7Kdz/+3//TytWrNB///d/a/fu3Xr++ee1adMmjRgxQpIq1AsAAAAAwHtV+WsaNm3apC5dulg/l4TmgQMHKjk5WWPHjlVeXp4ee+wxZWdn68Ybb9SKFSvk7+9vPeaDDz7QiBEj1LVrVzkcDvXp00evv/66tT04OFiff/65hg8frri4ONWuXVsTJ050+670jh07av78+Xr22Wf1zDPP6Nprr9WiRYvUvHlza01FegEAAAAAeCduElfF8F2HAAAAl4bvQceVxvegozxV/hJ3AAAAAADsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABH083AAAAvFvD8Us93QIqkQPTEj3dAgB4DGfQAQAAAACwAQI6AAAAAAA2QEAHAAAAAMAGCOgAAAAAANgAAR0AAAAAABsgoAMAAAAAYAMEdAAAAAAAbICADgAAAACADfh4ugEAqOwajl/q6RZQiRyYlujpFgAAwO+EM+gAAAAAANgAAR0AAAAAABsgoAMAAAAAYAMEdAAAAAAA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jJumqUGDBmno0KFq27atDhw4UNFxAa/EGXTgChg+fLh27Nihf/zjH5e9jx07dujOO+/UpEmT1KNHj1Lbv/zyS23atElz587Vq6++qg8//FCS9MEHH6hGjRrWny+//PKyewDK4+3H+H/+8x/17NlT9913nx599NHLngGVmzcf508//bRSU1P1+eefy+l06uGHH5Zpmpc9ByonbzzG33jjDZ04cUITJky47J4Bb8IZdOA3GjFihJYsWaL169crMjLSqkdERKiwsFDZ2dluv5XOzMxURESE2z527dqlrl276rHHHtOzzz5b5vNER0dLkq6//nplZmbq+eefV//+/dW7d2916NDBWnf11Vfrl19+sZ6rbt26bs/dqlWr3zoyqhhvP8bT09PVpUsXdezYUW+//fZlvQao/Lz9OK9du7Zq166tJk2aKCYmRlFRUfr6668VHx9/Wa8HKh9vPcbXrFmjlJQU+fn5uT1P27ZtNWDAAL333nuX/mIANsYZdOAymaapESNG6JNPPtGaNWus/yCViIuLU7Vq1bR69WqrtmfPHh08eNDtf5h27typLl26aODAgfrLX/5Soed2uVwqKCiQJNWsWVONGze2/gQEBCg6OloRERFuz52bm6tvvvmG/1lDhVWGY/w///mPbrnlFsXFxWnevHlyOPjPHtxVhuO8rP1KsvaNqs3bj/HXX39d3333nbZu3aqtW7dq2bJlkqQFCxZUuA/Aq3jyDnWANxs2bJgZHBxsrl271vzll1+sP/n5+daaoUOHmvXr1zfXrFljbtq0qdRX32zfvt0MCwszH3zwQbd9HD582Foza9Ys89NPPzX37t1r7t2713znnXfMmjVrmn/6059+tb9p06aZISEh5uLFi81t27aZd955Z6mvLfnpp5/M1NRUc/LkyWaNGjXM1NRUMzU11Txx4sQVfKXgrbz9GD906JDZuHFjs2vXruahQ4fcnh8o4e3H+ddff22+8cYbZmpqqnngwAFz9erVZseOHc1GjRqZp0+fvsKvFryRtx/jF0pLS+Mu7qjUCOjAZZJU5p958+ZZa06dOmU+/vjj5lVXXWVWr17dvPvuu93CwaRJk8rcR4MGDaw1r7/+utmsWTOzevXqZlBQkNm6dWtzzpw5ZnFx8a/253K5zOeee84MDw83/fz8zK5du5p79uxxWzNw4MAyn/+LL764Ei8RvJy3H+Pz5s0rdwaghLcf59u2bTO7dOli1qpVy/Tz8zMbNmxoDh061Dx06NAVe43g3bz9GL8QAR2VnWGa3EEEAAAAAABP48N4AAAAAADYAAEdAAAAAAAbIKADAAAAAGADBHQAAAAAAGyAgA4AAAAAgA0Q0AEAAAAAsAECOgAAVdSePXs0ZcoUnT592tOtAAAASXwPOgAAVVBxcbE6deqkWrVq6frrr9f06dM93RIAAFUeZ9ABAKgEBg0aJMMwNHTo0FLbhg8fLsMwNGjQIKv20ksv6ZZbbtGnn36qb775Rhs3bvwDuwUAAGXhDDoAAJXAoEGDtGbNGuXm5uqXX35RQECAJOn06dOqW7eugoKC1KVLFyUnJ3u2UQAAUC7OoAMAUEm0adNGUVFR+t///V+r9r//+7+qX7++WrdubdVcLpemTp2q6OhoBQQEqGXLlvr444+t7cePH9eAAQMUFhamgIAAXXvttZo3b94fOgsAAFURAR0AgErkkUcecQvT7777rpKSktzWTJ06VX/72980d+5c7dy5U6NHj9aDDz6odevWSZKee+457dq1S8uXL9f333+vN998U7Vr1/5D5wAAoCriEncAACqBQYMGKTs7W3/9618VFRWlPXv2SJKaNm2qn3/+WUOGDFFISIjeeust1apVS//6178UHx9vPX7IkCHKz8/X/Pnz1bt3b9WuXVvvvvuup8YBAKBK8vF0AwAA4MoJCwtTYmKikpOTZZqmEhMT3c5+//DDD8rPz1f37t3dHldYWGhdBj9s2DD16dNHW7ZsUY8ePXTXXXepY8eOf+gcAABURQR0AAAqmUceeUQjRoyQJM2ePdtt28mTJyVJS5cu1dVXX+22zc/PT5LUq1cv/fTTT1q2bJlWrVqlrl27avjw4XrppZf+gO4BAKi6COgAAFQyPXv2VGFhoQzDUEJCgtu22NhY+fn56eDBg+rcuXO5+wgLC9PAgQM1cOBA3XTTTXr66acJ6AAA/M4I6AAAVDJOp1Pff/+99c/nq1mzpp566imNHj1aLpdLN954o3JycvTvf/9bQUFBGjhwoCZOnKi4uDg1a9ZMBQUFWrJkiWJiYjwxCgAAVQoBHQCASigoKKjcbX/+858VFhamqVOnav/+/QoJCVGbNm30zDPPSJJ8fX01YcIEHThwQAEBAbrpppv0j3/8449qHQCAKou7uAMAAAAAYAN8DzoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADZAQAcAAAAAwAYI6AAAAAAA2AABHQAAAAAAGyCgAwAAAABgAwR0AAAAAABsgIAOAAAAAIANENABAAAAALABAjoAAAAAADbw/wEjMzLxugjuigAAAABJRU5ErkJggg==",
  "format": "base64_png",
  "metadata": {
    "title": "Gráfico de Vendas Mensais"
  }
}
app/backend/agent/requirements.txt

fastapi
uvicorn
openai>=1.0.0
python-multipart
typing
matplotlib 
pandas
pydantic
app/backend/agent/tools.py

# tools.py
import json
import sqlite3
from typing import Dict, Any, List
import matplotlib.pyplot as plt
import io
import base64
import os

class AgentTools:
    def __init__(self):
        # Configurar a conexão com o banco de dados
        self.db_path = os.environ.get("DB_PATH", "database.sqlite")
        
        # Criar diretório para salvar arquivos de resposta se não existir
        self.output_dir = os.environ.get("OUTPUT_DIR", "outputs")
        os.makedirs(self.output_dir, exist_ok=True)
    
    def save_agent_response(self, response: Dict[str, Any], 
                            filepath: str = None):
        """Salva a resposta do agente em um arquivo JSON."""
        if filepath is None:
            filepath = os.path.join(self.output_dir, 'agent-response.json')
            
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(response, f, ensure_ascii=False, indent=2)
        
        return filepath
    
    def query_sqlite(self, query: str) -> List[Dict]:
        """Executa uma consulta SQL e retorna os resultados como lista de dicionários."""
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute(query)
            results = [dict(row) for row in cursor.fetchall()]
            conn.close()
            return results
        except sqlite3.Error as e:
            return {"error": str(e)}
    
    def generate_sales_chart(self):
        """Gera um gráfico de vendas e retorna uma imagem codificada em base64."""
        try:
            # Buscar dados de vendas do banco de dados
            data = self.query_sqlite("SELECT month, sales FROM sales_data ORDER BY month")
            
            if not data or "error" in data:
                return {"type": "error", "content": "Erro ao buscar dados de vendas"}
            
            # Preparar dados para o gráfico
            months = [item['month'] for item in data]
            sales = [item['sales'] for item in data]
            
            # Criar o gráfico
            plt.figure(figsize=(10, 6))
            plt.bar(months, sales)
            plt.title('Vendas por Mês')
            plt.xlabel('Mês')
            plt.ylabel('Vendas (R$)')
            plt.grid(axis='y', linestyle='--', alpha=0.7)
            
            # Salvar o gráfico em um buffer
            buffer = io.BytesIO()
            plt.savefig(buffer, format='png')
            plt.close()
            buffer.seek(0)
            
            # Converter para base64
            image_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
            
            # Criar resposta
            response = {
                "type": "chart",
                "content": image_base64,
                "format": "base64_png",
                "metadata": {"title": "Gráfico de Vendas Mensais"}
            }
            
            # Salvar a resposta
            self.save_agent_response(response)
            
            return response
        except Exception as e:
            return {"type": "error", "content": f"Erro ao gerar gráfico: {str(e)}"}
app/backend/agent/whisper_handler.py

import tempfile
import os
from openai import OpenAI

client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

async def transcribe_audio(file):
    """
    Transcreve um arquivo de áudio usando a API da OpenAI.
    
    Args:
        file: O arquivo de áudio enviado pelo cliente.
        
    Returns:
        str: O texto transcrito do áudio.
    """
    try:
        # Criar um arquivo temporário para salvar o conteúdo do áudio
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as tmp:
            content = await file.read()
            tmp.write(content)
            tmp_path = tmp.name

        # Abrir o arquivo e fazer a transcrição
        print("Agora testando o modelo whisper para transcrição")
        with open(tmp_path, "rb") as audio_file:
            transcript = client.audio.transcriptions.create(
                #model="gpt-4o-transcribe",
                model="whisper-1",  # Usando modelo correto do Whisper
                file=audio_file,
                response_format="text"
            )
            
        # Limpar o arquivo temporário
        os.unlink(tmp_path)
        
        return transcript
    except Exception as e:
        # Garantir que o arquivo temporário seja removido mesmo em caso de erro
        if 'tmp_path' in locals():
            try:
                os.unlink(tmp_path)
            except:
                pass
        raise e
app/backend/docker-compose.yml

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: pythonbackend
    ports:
      - "8000:8000"
    environment:      
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    volumes:
      - "J:/backupD/drive_Dados/streamlit apps/26_Agentes_IA/presentation_remix_project/app/backend/agent:/app"
app/components/Canvas.tsx

// app/components/Canvas.tsx
import React, { useState, useEffect } from 'react';
import type { AgentResponse } from '~/services/remoteAgent';

// Componentes de renderização
const TextRenderer: React.FC<{ content: string }> = ({ content }) => (
  <div className="text-content">{content}</div>
);

const ChartRenderer: React.FC<{ content: string | Buffer }> = ({ content }) => {
  // Handle base64 string directly
  if (typeof content === 'string') {
    return (
      <div className="chart-container">
        <img
          src={`data:image/png;base64,${content}`}
          alt="Gráfico gerado"
        />
      </div>
    );
  }
  // Handle binary Buffer or Uint8Array
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  useEffect(() => {
    if (content instanceof Uint8Array || content instanceof Buffer) {
      const blob = new Blob([content], { type: 'image/png' });
      const url = URL.createObjectURL(blob);
      setImageUrl(url);
      return () => URL.revokeObjectURL(url);
    }
  }, [content]);
  return (
    <div className="chart-container">
      {imageUrl && <img src={imageUrl} alt="Gráfico gerado" />}
    </div>
  );
};

const PDFRenderer: React.FC<{ content: Buffer }> = ({ content }) => {
  const [pdfUrl, setPdfUrl] = useState<string | null>(null);

  useEffect(() => {
    // Converter buffer para URL de PDF
    const blob = new Blob([content], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);
    setPdfUrl(url);

    // Limpar URL criada quando o componente desmontar
    return () => URL.revokeObjectURL(url);
  }, [content]);

  return (
    <div className="pdf-container">
      {pdfUrl ? (
        <iframe 
          src={pdfUrl} 
          width="100%" 
          height="600px" 
          title="PDF Gerado"
        />
      ) : (
        <p>Carregando PDF...</p>
      )}
    </div>
  );
};

const DatabaseResultRenderer: React.FC<{ content: any[] }> = ({ content }) => {
  // Renderização flexível para resultados de banco de dados
  return (
    <div className="database-results">
      <table>
        <thead>
          <tr>
            {content.length > 0 && 
              Object.keys(content[0]).map((key) => (
                <th key={key}>{key}</th>
              ))
            }
          </tr>
        </thead>
        <tbody>
          {content.map((row, index) => (
            <tr key={index}>
              {Object.values(row).map((cell, cellIndex) => (
                <td key={cellIndex}>{String(cell)}</td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

const ErrorRenderer: React.FC<{ content: string, metadata?: any }> = ({ 
  content, 
  metadata 
}) => (
  <div className="error-container">
    <h3>Erro na Operação</h3>
    <p>{content}</p>
    {metadata && (
      <details>
        <summary>Detalhes do Erro</summary>
        <pre>{JSON.stringify(metadata, null, 2)}</pre>
      </details>
    )}
  </div>
);

export default function Canvas({ response }: { response: AgentResponse }) {
  // Renders non-text agent responses (chart, pdf, database, error, etc.)
  // For text responses, Layout should use OutputDisplay instead

  if (!response) {
    return <div>Carregando resposta do agente...</div>;
  }

  const renderContent = () => {
    switch (response.type) {
      case 'chart':
        // content expected as base64 or Buffer
        return <ChartRenderer content={response.content as any} />;
      case 'pdf':
        return <PDFRenderer content={response.content as any} />;
      case 'database':
        return <DatabaseResultRenderer content={response.content as any[]} />;
      case 'error':
        return <ErrorRenderer content={response.content as string} metadata={response.metadata} />;
      default:
        return <div>Tipo de resposta não suportado: {String(response.type)}</div>;
    }
  };

  return (
    <div className="canvas-container w-full p-4 bg-white shadow-md rounded-lg">      
        {response.metadata?.title && <h2>{response.metadata.title}</h2>}
        {response.metadata?.description && <p>{response.metadata.description}</p>}
      {renderContent()}
    </div>
  );
}
app/components/CommandInput.tsx

// app/components/CommandInput.tsx
import { useState } from "react";
import VoiceInput from "./VoiceInput";
import { useCommandStore } from "~/store/useCommandStore";
import type { AgentResponse } from "~/services/remoteAgent";

export default function CommandInput() {
  const setResponse = useCommandStore((state) => state.setResponse);
  const [command, setCommand] = useState("");

  const handleSubmit = async () => {
    if (!command.trim()) return;
  
    try {
      const res = await fetch("/api/run-agent", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt: command }),
      });
  
      if (!res.ok) {
        const msg = await res.text();
        console.error("Erro na resposta do agente:", msg);
        // store an error response
        setResponse({
          input: command,
          response: { type: "error", content: `Erro: ${msg}` },
        });
        return;
      }

      // full AgentResponse including type, content, metadata, etc.
      const data: AgentResponse = await res.json();
      setResponse({ input: command, response: data });
    } catch (err: any) {
      console.error("Erro na requisição ao agente:", err);
      // store an error response
      setResponse({
        input: command,
        response: { type: "error", content: "Erro ao conectar com o agente." },
      });
    }
  };
  

  return (
    <div className="bg-black p-4 shadow rounded">
      <h2 className="text-lg font-semibold text-red-700 mb-2">Comando do Agente</h2>
      <textarea
        className="w-full p-2 border rounded resize-none bg-gray-800 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
        rows={5}
        value={command}
        onChange={(e) => setCommand(e.target.value)}
        placeholder="Digite ou fale seu comando..."
      />
      <div className="flex items-center gap-2 mt-2">
        <button
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          onClick={handleSubmit}
        >
          Executar
        </button>
        <VoiceInput />
      </div>
    </div>
  );
}
app/components/Header.tsx

// app/components/Header.tsx
export default function Header() {
    return (
      <header className="bg-white shadow p-4">
        <h1 className="text-xl font-bold text-gray-800">
          🔧 Gerador de Rotas Inteligente
        </h1>
      </header>
    );
  }
  
app/components/Layout.tsx

// app/components/Layout.tsx
import { useCommandStore } from "~/store/useCommandStore";
import Header from "./Header";
import CommandInput from "./CommandInput";
import { OutputDisplay } from "./OutputDisplay";
import Canvas from "./Canvas";

export default function Layout() {
    const inputText = useCommandStore((state) => state.inputText);
    const agentResponse = useCommandStore((state) => state.agentResponse);

  return (
    <div className="min-h-screen flex flex-col bg-gray-150">
      <Header />
      <main className="flex-1 flex flex-col md:flex-row p-4 gap-4">
        <section className="w-full md:w-1/2">
          {/* <CommandInput
            onResponse={({ input, output }) => {
              setTranscription(input);
              setResponse(output);
            }}
          /> */}
          <CommandInput />
        </section>
        <section className="w-full md:w-1/2">
          {/* <OutputDisplay text={transcription || "Aguardando transcrição..."} />
          <OutputDisplay text={response || "Aguardando resposta do agente..."} /> */}
          {/* Display the user's input as text */}
          <OutputDisplay
            response={{
              type: "text",
              content: inputText || "Aguardando entrada...",
            }}
          />
          {/* Display the agent's response: text via OutputDisplay, others via Canvas */}
          {agentResponse ? (
            agentResponse.type === 'text' ? (
              <OutputDisplay response={agentResponse} />
            ) : (
              <Canvas response={agentResponse} />
            )
          ) : (
            <OutputDisplay
              response={{
                type: "text",
                content: "Aguardando resposta do agente...",
              }}
            />
          )}          

        </section>
      </main>
    </div>
  );
}
app/components/OutputDisplay.tsx

// app/components/OutputDisplay.tsx

// export default function OutputDisplay({ text }: { text: string }) {
//   return (
//     <div className="bg-white p-4 shadow rounded min-h-[150px]">
//       <h2 className="text-lg font-semibold mb-2">Resultado</h2>
//       <pre className="whitespace-pre-wrap text-sm text-gray-700">{text}</pre>
//     </div>
//   );
// }

//import AgentResponse from "~/types/agentResponse";
import { AgentResponse } from "~/services/remoteAgent";

export function OutputDisplay({ response }: { response: AgentResponse }) {
  if (response.type === 'chart') {
    console.log("resposta recebida no formato chart");
    // base64 PNG
    return (
      <img
        src={`data:image/png;base64,${response.content}`}
        alt={response.metadata?.title ?? 'Sales chart'}
      />
    );
  }
  // fallback to text
  return <pre>{response.content}</pre>;
}
app/components/Sidebar.tsx


app/components/VoiceInput.tsx

import { useState, useRef } from "react";

import { useCommandStore } from "~/store/useCommandStore";

export default function VoiceInput() {
  const setResponse = useCommandStore((state) => state.setResponse);
  const [recording, setRecording] = useState(false);
  const [processing, setProcessing] = useState(false);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunks = useRef<Blob[]>([]);

  const startRecording = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mediaRecorder = new MediaRecorder(stream);
    mediaRecorderRef.current = mediaRecorder;

    audioChunks.current = [];

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) {
        audioChunks.current.push(e.data);
      }
    };

    mediaRecorder.onstop = async () => {
      setProcessing(true);
      const audioBlob = new Blob(audioChunks.current, { type: "audio/mp3" });
      const formData = new FormData();
      formData.append("audio", audioBlob, "recording.mp3");

      try {
        const transcribeRes = await fetch("/api/transcribe", {
          method: "POST",
          body: formData,
        });
        const { text } = await transcribeRes.json();
        console.log("Transcrição:", text);

        const agentRes = await fetch("/api/run-agent", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt: text }),
        });
        const { content } = await agentRes.json();
        setResponse({ input: text, output: content });
        //onResponse({ input: text, output: "(agent ainda não implementado)" });
      } catch (err) {
        console.error("Erro durante transcrição ou resposta:", err);
      } finally {
        setProcessing(false);
      }
    };

    mediaRecorder.start();
    setRecording(true);
  };

  const stopRecording = () => {
    mediaRecorderRef.current?.stop();
    setRecording(false);
  };

  return (
    <div className="flex items-center gap-4">
      <button
        onClick={recording ? stopRecording : startRecording}
        className={`px-4 py-2 text-white font-semibold rounded ${
          recording ? "bg-red-600" : "bg-green-600"
        }`}
      >
        {recording ? "Parar" : "Falar"}
      </button>

      {recording && <MicrophoneVisualizer />}
      {processing && <p className="text-sm text-yellow-500">Processando...</p>}
    </div>
  );
}

// Animação simples de microfone ativo
function MicrophoneVisualizer() {
  return (
    <div className="flex gap-1 items-end h-6 ml-4">
      {[...Array(5)].map((_, i) => (
        <div
          key={i}
          className="w-1 bg-white animate-pulse"
          style={{
            height: `${Math.random() * 24 + 8}px`,
            animationDelay: `${i * 0.1}s`,
            animationDuration: "0.6s",
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
          }}
        />
      ))}
    </div>
  );
}
app/components/WorkloadChart.tsx


app/data/routes.json


app/entry.client.tsx

/**
 * By default, Remix will handle hydrating your app on the client for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.client
 */

import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>
  );
});
app/entry.server.tsx

/**
 * By default, Remix will handle generating the HTTP Response for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.server
 */

import { PassThrough } from "node:stream";

import type { AppLoadContext, EntryContext } from "@remix-run/node";
import { createReadableStreamFromReadable } from "@remix-run/node";
import { RemixServer } from "@remix-run/react";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";

const ABORT_DELAY = 5_000;

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  // This is ignored so we can keep it in the template for visibility.  Feel
  // free to delete this parameter in your app if you're not using it!
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  loadContext: AppLoadContext
) {
  return isbot(request.headers.get("user-agent") || "")
    ? handleBotRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      )
    : handleBrowserRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      );
}

function handleBotRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onAllReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}

function handleBrowserRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onShellReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}
app/root.tsx

import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
  LiveReload
} from "@remix-run/react";
import type { LinksFunction } from "@remix-run/node";

import "./tailwind.css";

export const links: LinksFunction = () => [
  { rel: "preconnect", href: "https://fonts.googleapis.com" },
  {
    rel: "preconnect",
    href: "https://fonts.gstatic.com",
    crossOrigin: "anonymous",
  },
  {
    rel: "stylesheet",
    href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap",
  },
];

export default function App() {
  return (
    <html lang="pt-BR" className="bg-gray-900 text-black">
      <head>
        <Meta />
        <Links />
      </head>
      <body className="min-h-screen font-sans">
        <header className="p-4 bg-gray-800 border-b border-gray-700">
          <h1 className="text-2xl font-bold text-white">Agente de IA Interativo 🎤</h1>
        </header>
        <main className="p-4 max-w-4xl mx-auto">
          <Outlet />
        </main>
        <ScrollRestoration />
        <Scripts />        
      </body>
    </html>
  );
}
app/routes/_index.tsx

// app/routes/index.tsx
import Layout from "~/components/Layout";

export default function Index() {
  return <Layout />;
}
app/routes/api.run-agent.ts

// app/routes/api/run-agent.ts
import { json } from "@remix-run/node";
import type { ActionFunction } from "@remix-run/node";
// import { runAgent } from "~/services/remoteAgent";
import { sendTextToAgent } from "~/services/remoteAgent";

export const action: ActionFunction = async ({ request }) => {
  const { prompt } = await request.json();
  console.log("Prompt recebido:", prompt);

  //const result = await runAgent(prompt);

  // Send the prompt to the remote agent and get its message
  //const { message } = await sendTextToAgent(prompt);
  const agentResponse = await sendTextToAgent(prompt);
  //console.log("Mensagem recebida do agente:", agentResponse);
  
  // Return field 'content' so the frontend can destructure { content }
  //return json({ content: message });
  return json(agentResponse);
};

//create a dummy loader function
export const loader = async () => {
  return json({});
};
app/routes/api.transcribe.ts

// app/routes/api/transcribe.ts
import type { ActionFunction } from "@remix-run/node";
import { json } from "@remix-run/node";
import { unstable_parseMultipartFormData, unstable_createFileUploadHandler } from "@remix-run/node";

export const action: ActionFunction = async ({ request }) => {
  const uploadHandler = unstable_createFileUploadHandler({
    directory: "/tmp",
    maxPartSize: 10_000_000,
  });

  const formData = await unstable_parseMultipartFormData(request, uploadHandler);
  const file = formData.get("audio") as File;

  console.log("Arquivo recebido:", file.name, file.type, file.size);

  const response = await fetch("http://localhost:8000/transcribe", {
    method: "POST",
    body: (() => {
      const fd = new FormData();
      fd.append("file", file);
      return fd;
    })(),
  });

  const data = await response.json();
  return json(data);
};
app/services/remoteAgent.ts

//import { request } from "node:http";

// app/services/agent.ts
// type AgentResponse = {
//     type: "text" | "code" | "json" | "error";
//     content: string;
//   };

// type AgentResponse = {
//   message: string; // Alterado para um campo mais simples
// };
export type AgentResponse = {
    type: string;
    content: string;
    format?: string;
    metadata?: any;
  };
    
  // export async function runAgent(prompt: string): Promise<AgentResponse> {
  //   console.log("Executando agente com o prompt:", prompt);
  //   try {
  //     const response = await fetch("http://localhost:8000/agent/process", {
  //       method: "POST",
  //       headers: {
  //         "Content-Type": "application/json",
  //       },
  //       body: JSON.stringify({ content: prompt, type: "text" }),
  //     });

  //     console.log("Response status:", response);
  
  //     if (!response.ok) {
  //       const errorText = await response.text();
  //       return { type: "error", content: `Erro do agente: ${errorText}` };
  //     }
  
  //     const { response: content } = await response.json();
  //     return {
  //       type: "text", // você pode usar um analisador depois para definir tipo
  //       content,
  //     };
  //   } catch (error: any) {
  //     return {
  //       type: "error",
  //       content: `Erro ao executar agente: ${error.message}`,
  //     };
  //   }
  // }
  
  export async function sendTextToAgent(text: string): Promise<AgentResponse> {
    console.log("Enviando texto para o agente:", text);

    try {
        const response = await fetch("http://localhost:8000/agent/process", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ command: text }), // Enviando 'command'
        });

        console.log("Response status:", response);

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Erro do agente: ${errorText}`);
        }

        //const result: AgentResponse = await response.json();
        // pull back the full agent response object { type, content, ... }
        const agentResponse = await response.json() as AgentResponse;
        //console.log("++++++++++Resposta do agente:", agentResponse);
        //return result; // Retornando resposta do agente
        //return result.content; // Retornando apenas o conteúdo
        
        //return { message: result.content }; // Retornando apenas a mensagem (porque ela está vindo como " { type: 'text', content: 'Olá! Como posso ajudá-lo hoje?' }")
        // pass it straight through
        return agentResponse;
    } catch (error: any) {
        console.error("Erro ao enviar texto:", error.message);
        throw error; // Lançando o erro para ser tratado por quem chamou a função
    }
}

app/store/useCommandStore.ts

import { create } from 'zustand';
import type { AgentResponse } from '~/services/remoteAgent';

interface CommandStore {
  // last entered command text
  inputText: string;
  // full response from the agent, or null if none yet
  agentResponse: AgentResponse | null;
  setInputText: (input: string) => void;
  /**
   * Store both the input command and the full AgentResponse
   */
  setResponse: (args: { input: string; response: AgentResponse }) => void;
}

export const useCommandStore = create<CommandStore>((set) => ({
  inputText: '',
  agentResponse: null,
  setInputText: (input) => set({ inputText: input }),
  setResponse: ({ input, response }) =>
    set({ inputText: input, agentResponse: response }),
}));
app/tailwind.css

@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body {
  @apply bg-slate-300 dark:bg-gray-950;

  @media (prefers-color-scheme: dark) {
    color-scheme: dark;
  }
}
app/types/AgentResponse.ts

// types/AgentResponse.ts
export interface AgentResponse {
    type: 'text' | 'chart' | 'pdf' | 'database' | 'error';
    content: string | Buffer;
    metadata?: {
      title?: string;
      description?: string;
      // Outros metadados relevantes
    };
  }
app/utils/generateRoute.ts

export function generateRoute(routeName: string): string {
  return `
    import { json, LoaderFunction } from 'remix';
    
    export let loader: LoaderFunction = async () => {
      return json({ message: "Este é o conteúdo da rota ${routeName}" });
    };

    export default function ${routeName}() {
      return <div><h1>${routeName}</h1></div>;
    }
  `;
}
app/utils/writeRouteToFile.ts

import { writeFile } from 'fs';
import { generateRoute } from './generateRoute';

export function writeRouteToFile(routeName: string) {
  const routeCode = generateRoute(routeName);
  const filePath = `./app/routes/generated/${routeName}.tsx`;

  writeFile(filePath, routeCode, (err) => {
    if (err) throw err;
    console.log(`Rota ${routeName} gerada com sucesso!`);
  });
}
package.json

{
  "name": "",
  "private": true,
  "sideEffects": false,
  "type": "module",
  "scripts": {
    "build": "remix vite:build",
    "dev": "remix vite:dev",
    "lint": "eslint --ignore-path .gitignore --cache --cache-location ./node_modules/.cache/eslint .",
    "start": "remix-serve ./build/server/index.js",
    "typecheck": "tsc"
  },
  "dependencies": {
    "@react-pdf/renderer": "^4.3.0",
    "@remix-run/node": "^2.16.5",
    "@remix-run/react": "^2.16.5",
    "@remix-run/serve": "^2.16.5",
    "chart.js": "^4.4.9",
    "isbot": "^4.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@remix-run/dev": "^2.16.5",
    "@types/react": "^18.2.20",
    "@types/react-dom": "^18.2.7",
    "@typescript-eslint/eslint-plugin": "^6.7.4",
    "@typescript-eslint/parser": "^6.7.4",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.38.0",
    "eslint-import-resolver-typescript": "^3.6.1",
    "eslint-plugin-import": "^2.28.1",
    "eslint-plugin-jsx-a11y": "^6.7.1",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.4",
    "typescript": "^5.1.6",
    "vite": "^6.0.0",
    "vite-tsconfig-paths": "^4.2.1"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
postcss.config.js

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
remix.config.js

/** @type {import('@remix-run/dev').AppConfig} */
export default {
  ignoredRouteFiles: ["**/.*"],
  serverDependenciesToBundle: [/@syncfusion/]
};
remix.env.d.ts

/// <reference types="@remix-run/dev" />
/// <reference types="@remix-run/node" />
tailwind.config.ts

import type { Config } from "tailwindcss";

export default {
  content: ["./app/**/{**,.client,.server}/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      fontFamily: {
        sans: [
          "Inter",
          "ui-sans-serif",
          "system-ui",
          "sans-serif",
          "Apple Color Emoji",
          "Segoe UI Emoji",
          "Segoe UI Symbol",
          "Noto Color Emoji",
        ],
      },
    },
  },
  plugins: [],
} satisfies Config;
teste-projeto.txt

Token Usage:
GitHub Tokens: 6583
LLM Input Tokens: 0
LLM Output Tokens: 0
Total Tokens: 6583

FileTree:
.gitignore
README.md
app/backend/agent/main.py
app/backend/agent/requirements.txt
app/backend/agent/whisper_handler.py
app/backend/docker-compose.yml
app/components/Canvas.tsx
app/components/CommandInput.tsx
app/components/Header.tsx
app/components/Layout.tsx
app/components/OutputDisplay.tsx
app/components/Sidebar.tsx
app/components/VoiceInput.tsx
app/components/WorkloadChart.tsx
app/data/routes.json
app/entry.client.tsx
app/entry.server.tsx
app/root.tsx
app/routes/_index.tsx
app/routes/api.run-agent.ts
app/routes/api.transcribe.ts
app/services/remoteAgent.ts
app/store/useCommandStore.ts
app/tailwind.css
app/utils/generateRoute.ts
app/utils/writeRouteToFile.ts
package.json
postcss.config.js
remix.config.js
remix.env.d.ts
tailwind.config.ts
tsconfig.json
vite.config.ts

Analysis:
.gitignore

node_modules

/.cache
/build
.env
README.md

Projeto Agente PPT
Objetivo
O objetivo desse projeto é criar uma interface onde seja possível passar informações para um agente de IA, e exibir os resultados na mesma página, em uma seção exclusiva.
O projeto vai utilizar o framework Remix, e todas as bibliotecas usadas serão registradas nesse arquivo.

Declaração de Escopo do Projeto
Interface Intuitiva: Crie uma página com uma interface amigável onde você possa interagir com o agente. Inclua um campo de entrada para comandos ou perguntas.

Canvas ou Painel de Resultados: Dedique uma seção da página para exibir os resultados das tarefas executadas. Pode ser um canvas para visualizações gráficas ou um painel para texto e gráficos.

Comunicação com a API: Configure a comunicação entre sua aplicação e a API do agente de IA para enviar comandos e receber resultados.

Demonstração ao Vivo: Durante a palestra, execute comandos ao vivo e mostre como o agente processa as tarefas, exibindo os resultados no painel em tempo real.

Etapas de desenvolvimento
API para Modificação de Rotas: Crie uma API no Remix que permita modificar ou salvar informações relacionadas às rotas. Por exemplo, um endpoint POST que recebe dados para atualizar uma rota específica.

Detecção de Mudança: Implemente um sistema de detecção de mudanças no lado do servidor, que atualize a interface do usuário quando uma rota for modificada.

Re-renderização Automática: Utilize a funcionalidade de revalidação ou re-renderização automática do Remix para refletir as mudanças na interface do usuário assim que a rota for atualizada.

Feedback Visual: Garanta que o painel ou canvas na página mostre claramente as mudanças em tempo real, proporcionando um feedback visual instantâneo.

Estrutura inicial do Projeto
Relação de pastas e arquivos necessários
/app
├── /routes
│ ├── index.tsx # Rota principal que renderiza a interface geral
│ ├── /generated # Pasta para armazenar as rotas geradas dinamicamente
│ │ └── newRoute.tsx # Exemplo de uma rota gerada dinamicamente
├── /components
│ ├── Layout.tsx # Layout principal da aplicação
│ ├── Sidebar.tsx # Componente para a navegação lateral
│ ├── WorkloadChart.tsx # Componente para renderizar o gráfico de carga de trabalho
├── /utils
│ ├── generateRoute.ts # Função para gerar código de novas rotas
│ └── writeRouteToFile.ts # Função para escrever o código gerado no arquivo da rota
├── /services
│ └── agent.ts # Agente de IA que gera o código das rotas
├── /styles
│ └── global.css # Estilos globais
├── /data
│ └── routes.json # Arquivo JSON que mantém o histórico das rotas geradas
└── /config
└── remix.config.js # Arquivo de configuração do Remix

app/backend/agent/main.py

from fastapi import FastAPI, UploadFile, File
from whisper_handler import transcribe_audio
from openai import OpenAI
import os

app = FastAPI()
client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

@app.post("/transcribe")
async def transcribe(file: UploadFile = File(...)):
    transcript = await transcribe_audio(file)
    #return {"text": transcript}
    print("Transcrição gerada:", transcript)
    return {"text": transcript}

@app.post("/agent")
async def agent(input: dict):
    prompt = input["prompt"]
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[{"role": "user", "content": prompt}]
    )
    #return {"response": response.choices[0].message.content}
    return {
        "type": "text",
        "prompt": prompt,
        "response": response.choices[0].message.content
        }
app/backend/agent/requirements.txt

fastapi
uvicorn
openai>=1.0.0
python-multipart
app/backend/agent/whisper_handler.py

import tempfile
from openai import OpenAI
import os

client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

async def transcribe_audio(file):
    with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as tmp:
        content = await file.read()
        tmp.write(content)
        tmp_path = tmp.name

    with open(tmp_path, "rb") as audio_file:
        transcript = client.audio.transcriptions.create(
            model="gpt-4o-transcribe",
            file=audio_file,
            response_format="text"
        )
    return transcript
app/backend/docker-compose.yml

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: pythonbackend
    ports:
      - "8000:8000"
    environment:
      
      - OPENAI_API_KEY=${OPENAI_API_KEY}
app/components/Canvas.tsx

import { Outlet } from "@remix-run/react";

export default function Canvas() {
  return (
    <div className="bg-white p-4 shadow rounded min-h-[300px] mt-4">
      <h2 className="text-lg font-semibold mb-2">Canvas</h2>
      <div className="canvas-content">
        <Outlet />
      </div>
    </div>
  );
}
app/components/CommandInput.tsx

// app/components/CommandInput.tsx
import { useState } from "react";
import VoiceInput from "./VoiceInput";
import { useCommandStore } from "~/store/useCommandStore";

export default function CommandInput() {
  const setResponse = useCommandStore((state) => state.setResponse);
  const [command, setCommand] = useState("");

  const handleSubmit = async () => {
    if (!command.trim()) return;
  
    try {
      const res = await fetch("/api/run-agent", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt: command }),
      });
  
      if (!res.ok) {
        const msg = await res.text();
        console.error("Erro na resposta do agente:", msg);
        setResponse({ input: command, output: `Erro: ${msg}` });
        return;
      }
  
      const { content } = await res.json();
      setResponse({ input: command, output: content });
    } catch (err: any) {
      console.error("Erro na requisição ao agente:", err);
      setResponse({ input: command, output: "Erro ao conectar com o agente." });
    }
  };
  

  return (
    <div className="bg-black p-4 shadow rounded">
      <h2 className="text-lg font-semibold mb-2">Comando do Agente</h2>
      <textarea
        className="w-full p-2 border rounded resize-none bg-gray-800 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
        rows={5}
        value={command}
        onChange={(e) => setCommand(e.target.value)}
        placeholder="Digite ou fale seu comando..."
      />
      <div className="flex items-center gap-2 mt-2">
        <button
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          onClick={handleSubmit}
        >
          Executar
        </button>
        <VoiceInput />
      </div>
    </div>
  );
}
app/components/Header.tsx

// app/components/Header.tsx
export default function Header() {
    return (
      <header className="bg-white shadow p-4">
        <h1 className="text-xl font-bold text-gray-800">
          🔧 Gerador de Rotas Inteligente
        </h1>
      </header>
    );
  }
  
app/components/Layout.tsx

// app/components/Layout.tsx
import { useCommandStore } from "~/store/useCommandStore";
import Header from "./Header";
import CommandInput from "./CommandInput";
import OutputDisplay from "./OutputDisplay";
import Canvas from "./Canvas";

export default function Layout() {
    const inputText = useCommandStore((state) => state.inputText);
    const outputText = useCommandStore((state) => state.outputText);

  return (
    <div className="min-h-screen flex flex-col bg-gray-50">
      <Header />
      <main className="flex-1 flex flex-col md:flex-row p-4 gap-4">
        <section className="w-full md:w-1/2">
          {/* <CommandInput
            onResponse={({ input, output }) => {
              setTranscription(input);
              setResponse(output);
            }}
          /> */}
          <CommandInput />
        </section>
        <section className="w-full md:w-1/2">
          {/* <OutputDisplay text={transcription || "Aguardando transcrição..."} />
          <OutputDisplay text={response || "Aguardando resposta do agente..."} /> */}
          <OutputDisplay text={inputText || "Aguardando entrada..."} />
          <OutputDisplay text={outputText || "Aguardando resposta do agente..."} />
          {/* Canvas for nested AI agent output routes */}
          <Canvas />
        </section>
      </main>
    </div>
  );
}
app/components/OutputDisplay.tsx

// app/components/OutputDisplay.tsx
export default function OutputDisplay({ text }: { text: string }) {
  return (
    <div className="bg-white p-4 shadow rounded min-h-[150px]">
      <h2 className="text-lg font-semibold mb-2">Resultado</h2>
      <pre className="whitespace-pre-wrap text-sm text-gray-700">{text}</pre>
    </div>
  );
}
app/components/Sidebar.tsx


app/components/VoiceInput.tsx

import { useState, useRef } from "react";

import { useCommandStore } from "~/store/useCommandStore";

export default function VoiceInput() {
  const setResponse = useCommandStore((state) => state.setResponse);
  const [recording, setRecording] = useState(false);
  const [processing, setProcessing] = useState(false);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunks = useRef<Blob[]>([]);

  const startRecording = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mediaRecorder = new MediaRecorder(stream);
    mediaRecorderRef.current = mediaRecorder;

    audioChunks.current = [];

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) {
        audioChunks.current.push(e.data);
      }
    };

    mediaRecorder.onstop = async () => {
      setProcessing(true);
      const audioBlob = new Blob(audioChunks.current, { type: "audio/mp3" });
      const formData = new FormData();
      formData.append("audio", audioBlob, "recording.mp3");

      try {
        const transcribeRes = await fetch("/api/transcribe", {
          method: "POST",
          body: formData,
        });
        const { text } = await transcribeRes.json();
        console.log("Transcrição:", text);

        const agentRes = await fetch("/api/run-agent", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt: text }),
        });
        const { content } = await agentRes.json();
        setResponse({ input: text, output: content });
        //onResponse({ input: text, output: "(agent ainda não implementado)" });
      } catch (err) {
        console.error("Erro durante transcrição ou resposta:", err);
      } finally {
        setProcessing(false);
      }
    };

    mediaRecorder.start();
    setRecording(true);
  };

  const stopRecording = () => {
    mediaRecorderRef.current?.stop();
    setRecording(false);
  };

  return (
    <div className="flex items-center gap-4">
      <button
        onClick={recording ? stopRecording : startRecording}
        className={`px-4 py-2 text-white font-semibold rounded ${
          recording ? "bg-red-600" : "bg-green-600"
        }`}
      >
        {recording ? "Parar" : "Falar"}
      </button>

      {recording && <MicrophoneVisualizer />}
      {processing && <p className="text-sm text-yellow-500">Processando...</p>}
    </div>
  );
}

// Animação simples de microfone ativo
function MicrophoneVisualizer() {
  return (
    <div className="flex gap-1 items-end h-6 ml-4">
      {[...Array(5)].map((_, i) => (
        <div
          key={i}
          className="w-1 bg-white animate-pulse"
          style={{
            height: `${Math.random() * 24 + 8}px`,
            animationDelay: `${i * 0.1}s`,
            animationDuration: "0.6s",
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
          }}
        />
      ))}
    </div>
  );
}
app/components/WorkloadChart.tsx


app/data/routes.json


app/entry.client.tsx

/**
 * By default, Remix will handle hydrating your app on the client for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.client
 */

import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>
  );
});
app/entry.server.tsx

/**
 * By default, Remix will handle generating the HTTP Response for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.server
 */

import { PassThrough } from "node:stream";

import type { AppLoadContext, EntryContext } from "@remix-run/node";
import { createReadableStreamFromReadable } from "@remix-run/node";
import { RemixServer } from "@remix-run/react";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";

const ABORT_DELAY = 5_000;

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  // This is ignored so we can keep it in the template for visibility.  Feel
  // free to delete this parameter in your app if you're not using it!
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  loadContext: AppLoadContext
) {
  return isbot(request.headers.get("user-agent") || "")
    ? handleBotRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      )
    : handleBrowserRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      );
}

function handleBotRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onAllReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}

function handleBrowserRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onShellReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}
app/root.tsx

import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
  LiveReload
} from "@remix-run/react";
import type { LinksFunction } from "@remix-run/node";

import "./tailwind.css";

export const links: LinksFunction = () => [
  { rel: "preconnect", href: "https://fonts.googleapis.com" },
  {
    rel: "preconnect",
    href: "https://fonts.gstatic.com",
    crossOrigin: "anonymous",
  },
  {
    rel: "stylesheet",
    href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap",
  },
];

export default function App() {
  return (
    <html lang="pt-BR" className="bg-gray-900 text-white">
      <head>
        <Meta />
        <Links />
      </head>
      <body className="min-h-screen font-sans">
        <header className="p-4 bg-gray-800 border-b border-gray-700">
          <h1 className="text-2xl font-bold">Agente de IA Interativo 🎤</h1>
        </header>
        <main className="p-4 max-w-4xl mx-auto">
          <Outlet />
        </main>
        <ScrollRestoration />
        <Scripts />        
      </body>
    </html>
  );
}
app/routes/_index.tsx

// app/routes/index.tsx
import Layout from "~/components/Layout";

export default function Index() {
  return <Layout />;
}
app/routes/api.run-agent.ts

// app/routes/api/run-agent.ts
import { json } from "@remix-run/node";
import type { ActionFunction } from "@remix-run/node";
import { runAgent } from "~/services/remoteAgent";

export const action: ActionFunction = async ({ request }) => {
  const { prompt } = await request.json();

  const result = await runAgent(prompt);

  return json(result);
};
app/routes/api.transcribe.ts

// app/routes/api/transcribe.ts
import type { ActionFunction } from "@remix-run/node";
import { json } from "@remix-run/node";
import { unstable_parseMultipartFormData, unstable_createFileUploadHandler } from "@remix-run/node";

export const action: ActionFunction = async ({ request }) => {
  const uploadHandler = unstable_createFileUploadHandler({
    directory: "/tmp",
    maxPartSize: 10_000_000,
  });

  const formData = await unstable_parseMultipartFormData(request, uploadHandler);
  const file = formData.get("audio") as File;

  console.log("Arquivo recebido:", file.name, file.type, file.size);

  const response = await fetch("http://localhost:8000/transcribe", {
    method: "POST",
    body: (() => {
      const fd = new FormData();
      fd.append("file", file);
      return fd;
    })(),
  });

  const data = await response.json();
  return json(data);
};
app/services/remoteAgent.ts

// app/services/agent.ts
type AgentResponse = {
    type: "text" | "code" | "json" | "error";
    content: string;
  };
  
  export async function runAgent(prompt: string): Promise<AgentResponse> {
    try {
      const response = await fetch("http://localhost:8000/agent", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ prompt }),
      });
  
      if (!response.ok) {
        const errorText = await response.text();
        return { type: "error", content: `Erro do agente: ${errorText}` };
      }
  
      const { response: content } = await response.json();
      return {
        type: "text", // você pode usar um analisador depois para definir tipo
        content,
      };
    } catch (error: any) {
      return {
        type: "error",
        content: `Erro ao executar agente: ${error.message}`,
      };
    }
  }
  
app/store/useCommandStore.ts

import {create} from 'zustand';

interface CommandStore {
  inputText: string;
  outputText: string;
  setInputText: (input: string) => void;
  setOutputText: (output: string) => void;
  setResponse: (args: { input: string; output: string }) => void;
}

export const useCommandStore = create<CommandStore>((set) => ({
  inputText: '',
  outputText: '',
  setInputText: (input) => set({ inputText: input }),
  setOutputText: (output) => set({ outputText: output }),
  setResponse: ({ input, output }) => set({ inputText: input, outputText: output }),
}));
app/tailwind.css

@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body {
  @apply bg-slate-300 dark:bg-gray-950;

  @media (prefers-color-scheme: dark) {
    color-scheme: dark;
  }
}
app/utils/generateRoute.ts

export function generateRoute(routeName: string): string {
  return `
    import { json, LoaderFunction } from 'remix';
    
    export let loader: LoaderFunction = async () => {
      return json({ message: "Este é o conteúdo da rota ${routeName}" });
    };

    export default function ${routeName}() {
      return <div><h1>${routeName}</h1></div>;
    }
  `;
}
app/utils/writeRouteToFile.ts

import { writeFile } from 'fs';
import { generateRoute } from './generateRoute';

export function writeRouteToFile(routeName: string) {
  const routeCode = generateRoute(routeName);
  const filePath = `./app/routes/generated/${routeName}.tsx`;

  writeFile(filePath, routeCode, (err) => {
    if (err) throw err;
    console.log(`Rota ${routeName} gerada com sucesso!`);
  });
}
package.json

{
  "name": "",
  "private": true,
  "sideEffects": false,
  "type": "module",
  "scripts": {
    "build": "remix vite:build",
    "dev": "remix vite:dev",
    "lint": "eslint --ignore-path .gitignore --cache --cache-location ./node_modules/.cache/eslint .",
    "start": "remix-serve ./build/server/index.js",
    "typecheck": "tsc"
  },
  "dependencies": {
    "@remix-run/node": "^2.16.5",
    "@remix-run/react": "^2.16.5",
    "@remix-run/serve": "^2.16.5",
    "isbot": "^4.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@remix-run/dev": "^2.16.5",
    "@types/react": "^18.2.20",
    "@types/react-dom": "^18.2.7",
    "@typescript-eslint/eslint-plugin": "^6.7.4",
    "@typescript-eslint/parser": "^6.7.4",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.38.0",
    "eslint-import-resolver-typescript": "^3.6.1",
    "eslint-plugin-import": "^2.28.1",
    "eslint-plugin-jsx-a11y": "^6.7.1",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.4",
    "typescript": "^5.1.6",
    "vite": "^6.0.0",
    "vite-tsconfig-paths": "^4.2.1"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
postcss.config.js

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
remix.config.js

/** @type {import('@remix-run/dev').AppConfig} */
export default {
  ignoredRouteFiles: ["**/.*"],
  serverDependenciesToBundle: [/@syncfusion/]
};
remix.env.d.ts

/// <reference types="@remix-run/dev" />
/// <reference types="@remix-run/node" />
tailwind.config.ts

import type { Config } from "tailwindcss";

export default {
  content: ["./app/**/{**,.client,.server}/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      fontFamily: {
        sans: [
          "Inter",
          "ui-sans-serif",
          "system-ui",
          "sans-serif",
          "Apple Color Emoji",
          "Segoe UI Emoji",
          "Segoe UI Symbol",
          "Noto Color Emoji",
        ],
      },
    },
  },
  plugins: [],
} satisfies Config;
tsconfig.json

{
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/.server/**/*.ts",
    "**/.server/**/*.tsx",
    "**/.client/**/*.ts",
    "**/.client/**/*.tsx"
  ],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "types": ["@remix-run/node", "vite/client"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "target": "ES2022",
    "strict": true,
    "allowJs": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    },

    // Vite takes care of building everything, not tsc.
    "noEmit": true
  }
}
vite.config.ts

import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

declare module "@remix-run/node" {
  interface Future {
    v3_singleFetch: true;
  }
}

export default defineConfig({
  plugins: [
    remix({
      future: {
        v3_fetcherPersist: true,
        v3_relativeSplatPath: true,
        v3_throwAbortReason: true,
        v3_singleFetch: true,
        v3_lazyRouteDiscovery: true,
      },
    }),
    tsconfigPaths(),	
  ],
  ssr: {
	noExternal: [
	/@syncfusion/, 
      "@mui/material",
      "@mui/icons-material",
      "ra-core",
      "ra-data-simple-rest", // Se você está usando esse provider
      "ra-data-json-server", // Para JSON Server
      "react-admin", // Pacote principal do React-admin
	  "ej2-react-buttons",
	]
	},
});
tsconfig.json

{
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/.server/**/*.ts",
    "**/.server/**/*.tsx",
    "**/.client/**/*.ts",
    "**/.client/**/*.tsx"
  ],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "types": ["@remix-run/node", "vite/client"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "target": "ES2022",
    "strict": true,
    "allowJs": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    },

    // Vite takes care of building everything, not tsc.
    "noEmit": true
  }
}
vite.config.ts

import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

declare module "@remix-run/node" {
  interface Future {
    v3_singleFetch: true;
  }
}

export default defineConfig({
  plugins: [
    remix({
      future: {
        v3_fetcherPersist: true,
        v3_relativeSplatPath: true,
        v3_throwAbortReason: true,
        v3_singleFetch: true,
        v3_lazyRouteDiscovery: true,
      },
    }),
    tsconfigPaths(),	
  ],
  ssr: {
	noExternal: [
	/@syncfusion/, 
      "@mui/material",
      "@mui/icons-material",
      "ra-core",
      "ra-data-simple-rest", // Se você está usando esse provider
      "ra-data-json-server", // Para JSON Server
      "react-admin", // Pacote principal do React-admin
	  "ej2-react-buttons",
	]
	},
});